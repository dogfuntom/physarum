{"mappings":"AAIQA","sources":["Dropbox/prj/physarum/artblocks_global_illumination/index.js"],"sourcesContent":["let S, ss, R, t, RL, SH\n// if (window.location.hash) {\n//     tokenData.hash = window.location.hash.slice(1)\n// }\nlet M = Math;\n\nlet rotArray = m => m[0].map((x, i) => m.slice().reverse().map(y => y[i]))\n\nlet preloader, preloaderSize\nconst typeBlock = 0, typeCyl = 1, typeBall = 2, typeBeak2x2 = 3, typeBeak2x2Flipped = 4,\n    typeArc = 5, typePillar = 6, typeEye = 7\nconst texSolid = 0, texLayers = 1, texGyr = 2\nconst texNorm = 2, texAO = 3\nconst blocksNumMax = 60\nconst maxMaxTry = 30\nlet u_camAngYZ = .95532, u_camAngXZ\n// let gs, blocksNumber, fitnessFunctionNumber, maxTry, extra\nlet s, sf, sv, b, canvas\nlet u_palette, u_colors, u_rotations, u_positions, u_sizes, u_types\nlet gs, blocksNumber, fitnessFunctionNumber, maxTry, extra, numberOfBlockTypes\nlet features\nlet blocksHeightMap, disallowedHeightMap;\nlet blocks\nlet vertices\nlet palette\nlet u_tick\nlet viewBox\n// let viewBox ={}\n\n/*\nБаги\n- Пингвинчик!\n- Прелоудер\n- На айфоне чтобы работало\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n- Скачивалку в большом размере\n- Скачивалку JSON файла\n\n✓ beak пофиксить: точно резать + пипки не обрезать.\n✓ Попробовать клюв с цилиндром\n✓ Кодгольфнуть вершины\n✓ В цветовые схемы добавить 7 цветов. Можно на бумажке ещё раз записать, какие буду схемы и фичи\n✓ Попробовать запретить текстуры для больших\n✓ Решить, текстуры будут меняться в зависимости от цветовой схемы? Например, будет ли цветовая схема «без»\n✓ Правильный подсчёт блоков\n✓ Радуга чтобы ресайзилась под размер модельки\n✓ Убрать мышиную крутилку\n✓ На мобиле чтобы работало\n✓ Пофиксить глаза раскосые\n✓ Аватар фит (квадратные штуки слишком большие)\n✓ Студшейп\n✓ глаза!\n✓ нижняя цеплялка не работает\n✓ bg переделать на что-то типа глоу. Чтобы не было глючного засвета\n✓ рефакторнуть глсл main\n✓ вернуть арку\n✓ рефакторнуть глсл SDF\n✓ убрать шафлы\n✓ сделать 10 разных вариантов рендеринга, выбрать лучший.\n✓ Набор удачных пресетов\n*/\n\n\nlet init = () => {\n    console.log(tokenData.hash)\n    S = Uint32Array.from([0, 1, ss = t = 2, 3].map(i => parseInt(tokenData.hash.substr(i * 8 + 2, 8), 16))); R = _ => (t = S[3], S[3] = S[2], S[2] = S[1], S[1] = ss = S[0], t ^= t << 11, S[0] ^= (t ^ t >>> 8) ^ (ss >>> 19), S[0] / 2 ** 32); 'tx piter'\n    RL = (ar, p) => ar[ar.length * R() ** (p || 1) | 0]\n    SH = (ar) => { return ar.sort(() => R() - 0.5) }\n\n    vertices = []\n\n    /// ↓↓↓↓↓ should be changed if hash changes\n\n    u_tick = 1e-6 // so not to turn into int\n    features = {\n        symmetry: R() ** 4. * 2 | 0,\n        studs: R() ** 8 * 2 | 0,\n        palette: 0,\n        // 0 — textured, 1 — not textured, 2 - all blocks of the same color, 3 — raibow, 4 — gazya\n        colorScheme: (1 - R() ** .2) * 5 | 0,\n        layout: 0,\n        height: 0,\n        eyes: 0,\n        aerials: 0,\n        blocksNumber: 0,\n        bgType: RL([2, 1], .5),\n        bgLight: R() * 3 - 1 | 0,\n    }\n\n    u_camAngXZ = ((features.symmetry) - .5) * 3.1415 / 2 - 3.1415\n\n    let presets = [\n        {\n            gs: 8 + R() * 2 | 0,\n            blocksNumber: 30,\n            fitnessFunctionNumber: 5, // cage\n            maxTry: 8,\n            extra: 0,\n        },\n        {\n            gs: 8 + R() * 2 | 0,\n            blocksNumber: 30,\n            fitnessFunctionNumber: 3, // shroom\n            maxTry: 8,\n            extra: R() ** 4 * 8,\n        },\n        { // cutie\n            gs: 4,\n            blocksNumber: 3 + R() * 4 | 0,\n            fitnessFunctionNumber: 0,\n            maxTry: 1,\n            extra: 1,\n        },\n        {\n            gs: 6 + R() * 4 | 0,\n            blocksNumber: 10 + R() * 20 | 0,\n            fitnessFunctionNumber: 2, // low\n            maxTry: 6,\n            extra: R() * 2,\n        },\n        {\n            gs: 6 + (R() | 0),\n            blocksNumber: 10 + R() * 10 | 0,\n            fitnessFunctionNumber: 0, // random\n            maxTry: 4,\n            extra: R() ** 2 * 3,\n        },\n    ];\n\n    features.layout = R() ** .3 * presets.length | 0;\n\n    ({ gs, blocksNumber, fitnessFunctionNumber, maxTry, extra } = presets[features.layout])\n    numberOfBlockTypes = 2 + R() * 2 | 0\n\n    blocks = [];\n    palette = RL([\n        // // GOOD\n        [\"#ddd\", \"#888\", \"#555\", \"#222\", \"#aaa\"],\n        [\"#f26b21\", \"#f78e31\", \"#fbb040\", \"#cbdb47\", \"#99ca3c\", \"#208b3a\", \"#fcec52\"], // green orange\n        [\"#9b5de5\", \"#f15bb5\", \"#00bbf9\", \"#00f5d4\", \"#fee440\"], // colorful\n        [\"#f1faee\", \"#a8dadc\", \"#457b9d\", \"#1d3557\", \"#e63946\"], // magenta blue\n        [\"#50514f\", \"#f25f5c\", \"#247ba0\", \"#70c1b3\", \"#ffe066\"], // lego\n        [\"#541388\", \"#d90368\", \"#f1e9da\", \"#2e294e\", \"#ffd400\"],\n        [\"#1f2041\", \"#4b3f72\", \"#119da4\", \"#19647e\", \"#ffc857\"],\n        [\"#540d6e\", \"#ee4266\", \"#f3fcf0\", \"#1f271b\", \"#ffd23f\"],\n        [\"#e4572e\", \"#29335c\", \"#a8c686\", \"#669bbc\", \"#f3a712\"],\n\n    ], .5)\n    let badColor = palette.pop()\n    palette = SH(palette)\n    palette.push(badColor)\n    if (features.colorScheme == 2) palette = palette.slice(0, 2)\n}\n\nfunction placeBlocks() {\n    let blocksVariants = SH([\n        { // beak\n            size: [2, 1, 2],\n            maskTop: [[0, 1], [0, 1]],\n            type: typeBeak2x2,\n        },\n        { // beak flipped\n            size: [2, 1, 2],\n            maskBottom: [[0, 1], [0, 1]],\n            type: typeBeak2x2Flipped,\n        },\n        { // 4x2\n            size: [2, 1, 4],\n            type: typeBlock,\n        },\n        { // 3x2\n            size: [2, 1, 3],\n            type: typeBlock,\n        },\n        { // 6x1\n            size: [1, 1, 6],\n            type: typeBlock,\n        },\n        { // arc\n            size: [1, 2, 3],\n            maskBottom: [[1, 0, 1]],\n            type: typeArc,\n        },\n        { // line\n            size: [1, 1, 3],\n            type: typeBlock,\n        },\n        { // block\n            size: [2, 1, 2],\n            type: typeBlock,\n        },\n        { // 1x1\n            size: [1, 1, 1],\n            type: typeBlock,\n        },\n        { // 1x1 but high\n            size: [1, 2, 1],\n            type: typeBlock,\n        },\n\n    ].filter(d => d.size[2] < gs)).slice(0, numberOfBlockTypes)\n\n    let blocksVariantsExtra = SH([\n        { // Pillar\n            size: [1, 4, 1],\n            maskTop: [[0]],\n            type: typePillar,\n        },\n        { // eye\n            size: [1, .5, 1],\n            maskTop: [[0]],\n            type: typeEye,\n        },\n    ])\n\n    // карта высот. В тех местах, где заплетная клетка, уходит в минус бесконечность. Чтобы точно было меньше, чем в запретной карте высот\n    // обратим внимание, что икс снаружи, потом зет. Обычно наоборот, если что.\n    blocksHeightMap = Array(gs)\n        .fill()\n        .map(() => Array(gs).fill(0))\n    // запретная карта высот. Ну, как запретная. Просто нельзя ставить деталь ножкой на\n    // на клетку, если карта высот в этой клетке меньше карты запрета.\n    disallowedHeightMap = Array(gs)\n        .fill()\n        .map(() => Array(gs).fill(0))\n\n    for (let n = 0; n < blocksNumber; n++) {\n        let maxHeight = 0\n        let fitness, maxFitness = -9e9\n        let bv\n        let bvt\n        let isExtra = false\n        let bvtInitial = RL(blocksVariants)\n        if (n >= blocksNumber - extra && features.colorScheme != 4)\n            bvtInitial = RL(blocksVariantsExtra, .7), fitnessFunctionNumber = 6, maxTry = 6, isExtra = true\n        // Цикл обслуживает фитнес. Бросаем деталь М раз и выбираем оптимальный,\n        // тот, что лучше подходит под критерий.\n        // Открытый вопрос, что делать, если ничего не подошло. Варианты:\n        // - добиться редкости случаев, когда пазл не сложился.\n        //   И в этом случае тупо всё сначала начинать с новым сидом.\n        // - сперва кидать самые большие детали, чтобы не вышло, что я положил один штырь, и никто не может к нему прицепиться\n        // - засчитывать только те попытки, когда деталь не нарушает правил. Иначе упрёмся в безысходный максимум.\n\n        for (let try_ = 0; try_ < maxTry; try_++) {\n            bvt = JSON.parse(JSON.stringify(bvtInitial))\n            bvt.color = R() * (palette.length - 1 | 0) + 1\n            bvt.color2 = R() * (palette.length - 1 | 0) + 1\n            bvt.texture = R() * 4 | 0\n            if (features.colorScheme == 1) bvt.texture = 0\n            // попался! bvt у нас сохранялся между выполнениями и портился от запуска к запуску.\n            // надо или его копию делать, или ещё чего.\n\n            // есть ли смысл тут сделать глубокую копию? Есть. И всё в ней хранить.\n            bvt.symX = true\n            bvt.rot = R() * 4 | 0 // (blockSizeTry.x%2==0 && blockSizeTry.z%2==0)?floor(R(4)):floor(R(2))*2\n            if (bvt.type == typeEye) bvt.rot = 0\n            let makeMask = () => Array(9).fill(Array(9).fill(1))\n            bvt.maskBottom = bvt.maskBottom || makeMask()\n            bvt.maskTop = bvt.maskTop || makeMask()\n            // Поворачиваем весь blockVariantTry на 90° несколько раз.\n            // Далее ротейт будет использоваться только для передачи в юниформ.\n            bvt.span = [...bvt.size]\n            for (let i = 0; i < bvt.rot; i++) {\n                // flipping sizes\n                // тут косяк. До этого мы деталь не крутили, только размеры подгоняли.\n                // теперь надо крутить, но размеры оставлять тут правильными. А вот координаты углов можно \n                // ставить с учётом повотора.\n                bvt.span.reverse()\n                //rotating matrices\n                bvt.maskBottom = rotArray(bvt.maskBottom)\n                bvt.maskTop = rotArray(bvt.maskTop)\n                bvt.symX = !bvt.symX\n            }\n            // интерраптинг, иф не влезло\n            if (bvt.span[0] > gs / 2) {\n                // console.log(bvt.span[0], 'is longer than ', gs)\n                if (maxTry < maxMaxTry) maxTry++; continue // можно макс макс трай убрать, если макс трай не очень мелкий\n            }\n            ///////////////////////////////////////////////////////////////////////////////////////////\n            ///////////////////////////////////////////////////////////////////////////////////////////\n            ///////////////////////////////////////////////////////////////////////////////////////////\n            if (gs % 2 == 0)\n                bvt.pos = [\n                    bvt.span[0] / 2 + (R() * (gs / 2 + 1 - bvt.span[0]) | 0),\n                    0,\n                    - gs / 2 + bvt.span[2] / 2 + (R() * (gs + 1 - bvt.span[2]) | 0),\n                ]\n            else {\n                bvt.pos = [\n                    bvt.span[0] / 2 + (R() * ((gs - 1) / 2 + 1 - bvt.span[0]) | 0) + .5,\n                    0,\n                    // - (gs - 1) / 2 + bvt.span[2] / 2 + (R() * (gs - 1 + 1 + 1 - bvt.span[2]) | 0) + .5-1,\n                    - gs / 2 + bvt.span[2] / 2 + (R() * (gs + 1 - bvt.span[2]) | 0),\n                ]\n            }\n            if (bvt.span[0] % 2 == gs % 2 && R() < 1 / (gs - bvt.span[0]))\n                if (bvt.span[0] % 2 || bvt.symX) // если чётное число пупырок, надо чтобы ось симетрии совпадала\n                    bvt.pos[0] = 0\n            // тут можно циклы выкинуть\n            let studL = 0\n            let studR = 0\n            let xx = [...Array(bvt.span[0])].map((d, i) => bvt.pos[0] + i - (bvt.span[0] - 1.) / 2)\n            let zz = [...Array(bvt.span[2])].map((d, i) => bvt.pos[2] + i - (bvt.span[2] - 1.) / 2)\n            for (let x of xx) {\n                for (let z of zz) {\n                    if (x >= 0) studR++;\n                    else studL++;\n                }\n            }\n\n            // if (\n            //     // блок про симметрию симметрии\n            //     (\n            //         (studL == 0) || // деталь не попала на ось симметрии\n            //         (studR == studL && bvt.symX)\n            //     )\n            //     //  && // стоит ровно посередине, ось симметрии совпадает\n            //     // bvt.span[0] <= gs &&\n            //     // bvt.span[2] <= gs\n            // ) { }\n            // else {\n            //     if(maxTry<maxMaxTry)maxTry++;\n            //     continue\n            // }\n\n\n            let maxHeightTry = 0;\n            let maxHeightTryLikeWithoutBottomHoles = 0;\n            let maxDisallowedHeightTry = 0;\n            let bi = 0\n            for (let z of zz) {\n                for (let x of xx) {\n                    let bx = bi % bvt.span[0]\n                    let bz = floor(bi / bvt.span[0])\n                    bi++\n                    maxHeightTryLikeWithoutBottomHoles = max(maxHeightTryLikeWithoutBottomHoles, blocksHeightMap[x + gs / 2 - .5][z + gs / 2 - .5]);\n                    maxDisallowedHeightTry = max(maxDisallowedHeightTry, disallowedHeightMap[x + gs / 2 - .5][z + gs / 2 - .5]);\n                    if (bvt.maskBottom[bx][bz] == 1) { // если посчитать только те, что с 1 внизу, высота не должна отличаться от той, что считается для всех клеток\n                        maxHeightTry = max(maxHeightTry, blocksHeightMap[x + gs / 2 - .5][z + gs / 2 - .5]);\n                    }\n                }\n            }\n            if (maxHeightTry < maxDisallowedHeightTry) {\n                if (maxTry < maxMaxTry) maxTry++; continue;\n            }\n            if (maxHeightTry > maxHeightTryLikeWithoutBottomHoles) {\n                if (maxTry < maxMaxTry) maxTry++; continue;\n            }\n            // TODO possible endless lop here!\n\n\n            let fitnessFunctions = [\n                0, // any\n                -M.hypot(bvt.pos[0], bvt.pos[2]), // high, bn 16 gs 10\n                -maxHeightTry, // low\n                -M.hypot(bvt.pos[0], maxHeightTry - 10, bvt.pos[2]), // mashroom\n                -abs(M.hypot(bvt.pos[0], maxHeightTry - 10, bvt.pos[2]) - gs), // cage\n                -abs(M.hypot(bvt.pos[0], maxHeightTry * 2, bvt.pos[2]) - gs), // cage: blocksNum = 90, gs = 16\n                maxHeightTry * 2. + bvt.pos[2], // eyes\n            ]\n            fitness = fitnessFunctions[fitnessFunctionNumber]\n\n            if (fitness > maxFitness || try_ == 0) {\n                maxFitness = fitness // maxfitness не нужен, если  || try_==0\n                maxHeight = maxHeightTry\n                bv = bvt\n            }\n        }\n        if (bv) {\n            bv.pos[1] = maxHeight + bv.size[1] / 2;\n            if (bv.pos[1]) {\n                if (isExtra && bv.pos[1]-bv.span[1]/2 == 0) {\n                    console.log('extra on the floor!'); continue\n                } // eyes on the froor are prohibited\n                let xx = Array(bv.span[0]).fill().map((d, i) => bv.pos[0] + i - (bv.span[0] - 1.) / 2)\n                let zz = Array(bv.span[2]).fill().map((d, i) => bv.pos[2] + i - (bv.span[2] - 1.) / 2)\n                let bi = 0\n                for (let z of zz) {\n                    for (let x of xx) {\n                        let bx = bi % bv.span[0]\n                        let bz = floor(bi / bv.span[0])\n                        bi++\n                        blocksHeightMap[x + gs / 2 - .5][z + gs / 2 - .5] = maxHeight + bv.size[1]\n                        if (bv.maskTop[bx][bz] == 0) blocksHeightMap[x + gs / 2 - .5][z + gs / 2 - .5] = -99\n                        disallowedHeightMap[x + gs / 2 - .5][z + gs / 2 - .5] = maxHeight + bv.size[1]\n                    }\n                }\n                blocks.push(bv)\n\n                // push vertices\n                for (let i = 0; i++ < 8;) {\n                    let s = [0, 0, 0].map((_, j) => ((i >> j) & 1) - .5) // permutations, 3 items of {.5, -.5} set\n                    vertices.push([\n                        s[0] * (bv.span[0] + 2 * bv.pos[0]), // pos shouldn't be divided by 2, compensating\n                        s[1] * bv.span[1] + bv.pos[1],\n                        s[2] * bv.span[2] + bv.pos[2]\n                    ])\n                }\n\n                features.blocksNumber++\n                if (bv.type == typeEye) features.eyes++\n                if (bv.type == typePillar) features.aerials++\n                if (bv.pos[0] > 0) {\n                    features.blocksNumber++\n                    if (bv.type == typeEye) features.eyes++\n                    if (bv.type == typePillar) features.aerials++\n                }\n            } else console.log('bv.pos.y is NaN')\n        } else console.log('bv not defined')\n    }\n    console.log('N BLOCKS', blocks.length, '\\n==============================')\n    console.log(blocks)\n    features.height = M.max(...disallowedHeightMap.flat())\n    // console.log('height_', height_)\n    // console.log('features', features)\n    // blocks=[]\n    // blocks.push({\n    //     type: 0,\n    //     size:[1,2,3],\n    //     pos: [0,0,0],\n    //     rot: 0,\n    //     color: 1,\n    //     color2: 1,\n    //     texture: 1,\n    // })\n}\n\nlet findViewBox = () => {\n    viewBox = { top: -1e9, bottom: 1e9, left: 1e9, right: -1e9 }\n    let rot = (x, y, a) => [x * cos(a) - y * sin(a), x * sin(a) + y * cos(a)]\n    vertices.forEach(v => {\n        let [x, y, z] = v;\n        [x, z] = rot(x, z, -u_camAngXZ);\n        [y, z] = rot(y, z, -u_camAngYZ)\n        viewBox.left = min(x, viewBox.left)\n        viewBox.right = max(x, viewBox.right)\n        viewBox.bottom = min(y, viewBox.bottom)\n        viewBox.top = max(y, viewBox.top)\n    })\n    viewBox.width = viewBox.right - viewBox.left\n    viewBox.height = viewBox.top - viewBox.bottom\n    viewBox.scale = max(viewBox.width / 1.8, viewBox.height / 1.8, 1)\n    viewBox.offset = { x: viewBox.left + viewBox.width / 2, y: viewBox.bottom + viewBox.height / 2 }\n}\n\n\n\n\n\n\n\nfunction preload() {\n\n}\n\nfunction setup() {\n\n    let size = min(windowHeight, windowWidth)\n    canvas = createCanvas(size, size, WEBGL)\n    b = createGraphics(width, height, WEBGL)\n    // tokenData.hash=arr.pop().hash\n\n    // Below part needs changing if hash changes\n\n    // pixelDensity(1)\n\n    init()\n\n    background(palette[0])\n\n    placeBlocks()\n\n    findViewBox()\n\n    u_sizes = blocks.map(b => b.size).flat()\n    u_positions = blocks.map(b => b.pos).flat()\n    u_palette = palette.map(c => color(c).levels.slice(0, 3)).flat().map(d => d / 255)\n    u_colors = blocks.map(b => [b.color, b.color2, b.texture]).flat()\n    u_types = blocks.map(b => b.type)\n    u_rotations = blocks.map(b => b.rot)\n    sf = `precision highp float;\n#define BLOCKS_NUMBER_MAX 60\n#define PI 3.1415\n#define S smoothstep\n#define V vec3\n#define v vec2\n#define rnd(x) fract(54321.987 * sin(987.12345 * mod(x,12.34567)))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define STEPS 4e2\n#define EPS .001\n#define box(p,s) (length(p - clamp(p, -(s)/2., (s)/2.)) - cornerR * 1.4)\n#define sabs(p) sqrt(abs(p)*abs(p)+.00005)\n#define smax(a,b) (a+b+sabs(a-b))*.5\n\nvarying v uv;\nuniform V positions[BLOCKS_NUMBER_MAX];\nuniform V sizes[BLOCKS_NUMBER_MAX];\nuniform ivec3 colors[BLOCKS_NUMBER_MAX];\nuniform int types[BLOCKS_NUMBER_MAX];\nuniform float rotations[BLOCKS_NUMBER_MAX];\nuniform V palette[20];\nuniform sampler2D b;\nuniform float t;\n\nivec3 colIds;\nfloat gl;\nfloat camDist = 400.;\nv u_res = v(${width}, ${height})*${pixelDensity()+1e-6};\n\n\nfloat cyl(V p, V s, float cornerR) {\n    // s.x — height\n    // s.y — thickness\n    // s.x — radius\n    p.y -= clamp(p.y, -s.x, s.x);\n    float len = length(p.xz) - s.z;\n    len -= clamp(len, -s.y, s.y);\n    float cyl = length(v(len, p.y)) - cornerR;\n    return cyl;\n}\n\nv random2f() {\n    v rn = v(rnd(length(uv) - t), rnd(length(uv) - t - .1));\n    float k = .5;\n    v a;\n    a.x = .5 * pow(2.0 * ((rn.x < 0.5) ? rn.x : 1.0 - rn.x), k);\n    a.y = .5 * pow(2.0 * ((rn.y < 0.5) ? rn.y : 1.0 - rn.y), k);\n    rn.x = (rn.x < 0.5) ? a.x : 1.0 - a.x;\n    rn.y = (rn.y < 0.5) ? a.y : 1.0 - a.y;\n    return rn * 2. - 1.;\n}\n\nint eye;\n\nfloat dist(V p) {\n    colIds = ivec3(0, 0, -1);\n    p.x = abs(p.x);\n    float res = p.y + 1.; // floor plane\n    for(int i = 0; i < BLOCKS_NUMBER_MAX; i++) {\n        eye = 0;\n        if(i >= ${blocks.length})\n            break;\n        V pb = p;\n        pb -= positions[i];\n        pb.xz *= rot(rotations[i] * PI / 2.);\n\n        // box\n        float cornerR = .01;//.025;//.05;\n        float gap = .008;\n        float block;\n        if(types[i] == 0 || types[i] == 3 || types[i] == 4 || types[i] == 5 || types[i] == 6 || types[i] == 7) {\n            block = box(pb, sizes[i] - 2. * (cornerR + gap));\n        } else if(types[i] == 1) { // cyl\n            block = max(length(pb.xz) - .5, abs(pb.y) - .5);\n        } else if(types[i] == 2) { // ball\n            block = length(pb) - .52;\n        }\n\n        if(types[i] == 5) {\n            float cyl = length(pb.zy) - .5;\n            float box = max(abs(pb.z) - .5, abs(pb.y + sizes[i].y / 2.) - 1.);\n            float hole = min(cyl, box);\n            block = max(block, -hole);\n        }\n\n        if(types[i] == 6) { // pillar\n            float cyl_ = length(pb.zx) - .15;\n            float sph = cyl(pb + V(0, sizes[i].y - .5, 0) / 2., V(.2, .25, .2), cornerR);\n            // float sph = length(pb) - .45;\n            block = max(block, min(cyl_, sph));\n        }\n\n        // studs\n        if(types[i] != 6) {\n            V ps = pb;\n            v l = sizes[i].xz;\n            ps.xz += (l - 1.) / 2.;\n            ps.xz = ps.xz - clamp(floor(ps.xz + .5), v(0.), l - 1.);\n            float h = .24;\n            float stud = (${features.studs} == 1) ? abs(length(ps.xz) - .28 + .05) - .05 : length(ps.xz) - .28;\n            stud = max(stud, abs(ps.y - sizes[i].y / 2. - h / 2.) - h / 2.);\n            block = min(stud, block);\n        }\n\n        // // rounded slopes\n        // if (pb.z<0.){\n        //     if(types[i] == 3) { // beak\n        //         block=max(block, length(pb.zy+v(0,sizes[i].y/2.))-1.);\n        //     }\n        //     if(types[i] == 4) { // beak down\n        //         block=max(block, length(pb.zy-v(0,sizes[i].y/2.))-1.);\n        //     }\n        // }\n\n        // old slopes\n        // if(types[i] == 3 || types[i] == 4) { // beak\n        //     // pb.z *= -1.;\n        //     V pe = pb;\n        //     pe.z += .55;\n        //     pe.yz *= rot(PI * .26);\n        //     // if(types[i] == 3)\n        //     //     pe.yz *= rot(-PI / 2.);\n        //     block = max(block, -pe.z);\n        // }\n\n        // if(types[i] == 3 || types[i] == 4) { // beak\n        //     if (pb.z<0.){\n        //         // pb*=1.0;\n        //         float s = 1.4142;\n        //         pb.zy+=vec2(1,.5);\n        //         pb.zy*=rot(-PI/4.);\n        //         vec2 n=vec2(0,1)*rot(-PI/8.);\n        //         // vec2 n=vec2(.3827,.9238);\n        //         pb.zy-=2.*min(.0,dot(pb.zy,n))*n;\n        //         pb.zy.x-=s;\n        //         n*=rot(-PI*1.5);\n        //         pb.zy-=2.*min(.0,dot(pb.zy,n))*n;\n        //         pb.zy-=clamp(pb.zy,-s,0.);\n        //         block = max(length(pb.zy)/2., block);\n        //         // block = length(pb.zy);\n        //     }\n        // }\n\n        if(pb.z<0.15 && (types[i] == 3 || types[i] == 4)) { // beak\n            block = smax(block, (-pb.z*.8-(types[i] == 3 ? -1. : 1.)*pb.y-.5)/1.4142);\n        }\n\n\n        if(types[i] == 7) { // eye\n            // pb.z -= .5;\n            // block = box(pb - V(0, 0, .5), V(1));\n            // pb.zy *= rot(PI / 2.);\n            // pb.y+=.25;\n            float eye_ = cyl(pb, V(.2, .25, .2), cornerR);\n            block = eye_;\n            if(eye_ < EPS) {\n                // eye = int(step(.3, length(pb.xz) - length(pb.xz * 2. - v(2)) / 3.));\n                eye = 1;\n                //-int(min(step(-.3,-),step(.3,)));\n            }\n            // block = max(block, min(cyl, sph));\n        }\n\n        if(block < res) {\n            res = block;\n            colIds = colors[i];\n        }\n        if(res < EPS)\n            break;\n    }\n    return res;\n}\n\nV norm(V p) {\n    v e = v(.01, 0.);\n    return normalize(V(dist(p + e.xyy) - dist(p - e.xyy), dist(p + e.yxy) - dist(p - e.yxy), dist(p + e.yyx) - dist(p - e.yyx)));\n}\n\nvoid main() {\n    gl = 0.;\n    float d = 0., e = 1e9, ep, j;\n    v uv_ = (uv*u_res/min(u_res.x,u_res.y)) + random2f() * 1.5 / u_res;\n    V p, ro = V(uv_ * float(${viewBox.scale}) + \n    v(${viewBox.offset.x}, \n    ${viewBox.offset.y}), -camDist), \n    rd = V(0, 0, .9 + .1 * rnd(length(uv_))), o;\n    bool outline = false;\n    for(float i = 0.; i < STEPS; i++) {\n        j = i;\n        p = d * rd + ro;\n        p.z -= camDist;\n        p.yz *= rot(${u_camAngYZ});\n        p.xz *= rot(${u_camAngXZ});\n        d += e = dist(p);\n        if(ep < e && e < .01) {\n            // gl_FragColor = vec4(0);\n            outline = true;\n            break;\n        }\n        ep = e;\n        // if(colIds.x > 0) { // if not floor, glow!\n        //     // gl +=  pow(.0000001 * e, .4);\n        // }\n        if(e < EPS || e > camDist*2.)\n            break;\n    }\n    if(!outline) {\n        V col1, col2;\n        for(int j = 0; j < 20; j++) {\n            if(colIds[0] == j)\n                col1 = palette[j];\n            if(colIds[1] == j)\n                col2 = palette[j];\n        }\n\n        V col = col1;\n\n        // Texturing\n        //\n        // layers\n        if(colIds.z == 1)\n            if(sin(p.y * PI * 3.) > 0.)\n                col = col2;\n        if(colIds.z == 2)\n            if(sin((p.x + fract(positions[0].x - sizes[0].x / 2.)) * PI * 2. * 1.5) > 0.)\n                col = col2;\n\n        // pride\n        if(${features.colorScheme} == 3)\n            col = sin(length(p) / max(float(${gs}), float(${features.height})) * 6.28 * 2. - V(0, PI * 2. / 3., PI * 4. / 3.)) * .5 + .5;\n            // p*=.3;\n            // col = sin(8.*dot(sin(p), cos(p.zxy))  - V(0, PI * 2. / 3., PI * 4. / 3.)) * .5 + .5;\n\n        if(eye == 1) {\n            col = V(0);\n            V pe = p + fract(${gs}. / 2.);\n            pe = fract(pe) - .5;\n            col += step(.3, length(pe.xz));\n            col += step(-.1, -length(pe.xz + .1));\n        }\n\n        if(colIds.z == -1) {\n            o = palette[0];\n            if(length(o) > .4)\n                o *= smoothstep(5., 0., length(uv_ + v(${features.bgLight}, -1)));\n            if(${features.colorScheme} == 3)\n                // o = V(o.r*.5);\n                o = V(.2);\n            if(sin(length(pow(abs(uv_), v(${features.bgType}))) * 32.) > 0.)\n                o *= .95;\n        } else {\n            // shading\n            o = (min(1.5, 14. / j) * .2 + .8) * (dot(norm(p), normalize(V(0, 1, 1))) * .2 + .8) * col;\n            // glare\n            o += pow(dot(norm(p), normalize(V(0, 3, 1))), 40.);\n        }\n    }\n\n    // gazya\n    if(${features.colorScheme} == 4)\n        o = (V(10. / j));\n\n    gl_FragColor = mix(texture2D(b, uv * v(1, -1) * .5 + .5), vec4(o, 1), 1. / (t + 1.));\n    // gl_FragColor = vec4(o*rnd(${u_tick}), 1);\n}`\n    sv = `attribute vec3 aPosition;\n    varying vec2 uv;\n    void main() {\n      vec4 positionVec4 = vec4(aPosition, 1.0);\n      uv = positionVec4.xy = positionVec4.xy * 2.0 - 1.0;\n      gl_Position = positionVec4;\n    }`\n    s = createShader(sv, sf)\n    // s = createShader(sv.join('\\n'), eval('`' + sf.join('\\n') + '`'))\n\n    preloaderSize = document.querySelector('canvas').getBoundingClientRect()\n    console.log(preloaderSize)\n    preloader = document.body.appendChild(document.createElement('div'))\n    preloader.style.position = 'absolute'\n    preloader.style.left = preloaderSize.x\n    preloader.style.top = preloaderSize.bottom - preloaderSize.height / 100\n    preloader.style.height = preloaderSize.height / 100\n    preloader.style.width = 0\n    preloader.style.background = '#fff9'\n\n    loop()\n    console.log('features', features)\n}\n\n\n\n\n\n\n\nfunction draw() {\n    b.clear();\n    b.image(canvas, width * -0.5, height * -0.5, width, height);\n    clear();\n    shader(s);\n    s.setUniform('b', b)\n    s.setUniform('t', u_tick)\n    s.setUniform('positions', u_positions)\n    s.setUniform('sizes', u_sizes)\n    s.setUniform('rotations', u_rotations)\n    s.setUniform('colors', u_colors)\n    s.setUniform('palette', u_palette)\n    s.setUniform('types', u_types)\n    rect(0, 0, width, height)\n\n    console.log(u_tick)\n    preloader.style.width = preloaderSize.width * u_tick / 5e1\n\n    if (u_tick++ > 5e1) {\n        preloader.remove()\n        noLoop()\n        // save(`${tokenData.hash}.png`)\n        // let gl = canvas.getContext('webgl')\n        // gl.getExtension('WEBGL_lose_context').loseContext()\n        // gl = b.getContext('webgl')\n        // document.querySelector('canvas').getContext('webgl').getExtension('WEBGL_lose_context').loseContext()\n        // setTimeout(setup, 500)\n    }\n}"],"names":["Math"],"version":3,"file":"index.js.map"}