let S,ss,R,t,RL,SH,preloader,preloaderSize,M=Math,rotArray=e=>e[0].map((n,o)=>e.slice().reverse().map(e=>e[o]));const typeBlock=0,typeCyl=1,typeBall=2,typeBeak2x2=3,typeBeak2x2Flipped=4,typeArc=5,typePillar=6,typeEye=7,texSolid=0,texLayers=1,texGyr=2,texNorm=2,texAO=3,blocksNumMax=60,maxMaxTry=30;let u_camAngXZ,s,sf,sv,b,canvas,u_palette,u_colors,u_rotations,u_positions,u_sizes,u_types,gs,blocksNumber,fitnessFunctionNumber,maxTry,extra,numberOfBlockTypes,features,blocksHeightMap,disallowedHeightMap,blocks,vertices,palette,u_tick,viewBox,u_camAngYZ=.95532,init=()=>{console.log(tokenData.hash),S=Uint32Array.from([0,1,ss=t=2,3].map(e=>parseInt(tokenData.hash.substr(8*e+2,8),16))),RL=((e,n)=>e[e.length*R()**(n||1)|0]),SH=(e=>e.sort(()=>R()-.5)),vertices=[],u_tick=1e-6,features={symmetry:(R=(e=>(t=S[3],S[3]=S[2],S[2]=S[1],S[1]=ss=S[0],t^=t<<11,S[0]^=t^t>>>8^ss>>>19,S[0]/2**32)))()**4*2|0,studs:R()**8*2|0,palette:0,colorScheme:5*(1-R()**.2)|0,layout:0,height:0,eyes:0,aerials:0,blocksNumber:0,bgType:RL([2,1],.5),bgLight:3*R()-1|0},u_camAngXZ=3.1415*(features.symmetry-.5)/2-3.1415;let e=[{gs:8+2*R()|0,blocksNumber:30,fitnessFunctionNumber:5,maxTry:8,extra:0},{gs:8+2*R()|0,blocksNumber:30,fitnessFunctionNumber:3,maxTry:8,extra:R()**4*8},{gs:4,blocksNumber:3+4*R()|0,fitnessFunctionNumber:0,maxTry:1,extra:1},{gs:6+4*R()|0,blocksNumber:10+20*R()|0,fitnessFunctionNumber:2,maxTry:6,extra:2*R()},{gs:6+(0|R()),blocksNumber:10+10*R()|0,fitnessFunctionNumber:0,maxTry:4,extra:R()**2*3}];features.layout=R()**.3*e.length|0,({gs:gs,blocksNumber:blocksNumber,fitnessFunctionNumber:fitnessFunctionNumber,maxTry:maxTry,extra:extra}=e[features.layout]),numberOfBlockTypes=2+2*R()|0,blocks=[];let n=(palette=RL([["#ddd","#888","#555","#222","#aaa"],["#f26b21","#f78e31","#fbb040","#cbdb47","#99ca3c","#208b3a","#fcec52"],["#9b5de5","#f15bb5","#00bbf9","#00f5d4","#fee440"],["#f1faee","#a8dadc","#457b9d","#1d3557","#e63946"],["#50514f","#f25f5c","#247ba0","#70c1b3","#ffe066"],["#541388","#d90368","#f1e9da","#2e294e","#ffd400"],["#1f2041","#4b3f72","#119da4","#19647e","#ffc857"],["#540d6e","#ee4266","#f3fcf0","#1f271b","#ffd23f"],["#e4572e","#29335c","#a8c686","#669bbc","#f3a712"]],.5)).pop();(palette=SH(palette)).push(n),2==features.colorScheme&&(palette=palette.slice(0,2))};function placeBlocks(){let e=SH([{size:[2,1,2],maskTop:[[0,1],[0,1]],type:typeBeak2x2},{size:[2,1,2],maskBottom:[[0,1],[0,1]],type:typeBeak2x2Flipped},{size:[2,1,4],type:typeBlock},{size:[2,1,3],type:typeBlock},{size:[1,1,6],type:typeBlock},{size:[1,2,3],maskBottom:[[1,0,1]],type:typeArc},{size:[1,1,3],type:typeBlock},{size:[2,1,2],type:typeBlock},{size:[1,1,1],type:typeBlock},{size:[1,2,1],type:typeBlock}].filter(e=>e.size[2]<gs)).slice(0,numberOfBlockTypes),n=SH([{size:[1,4,1],maskTop:[[0]],type:typePillar},{size:[1,.5,1],maskTop:[[0]],type:typeEye}]);blocksHeightMap=Array(gs).fill().map(()=>Array(gs).fill(0)),disallowedHeightMap=Array(gs).fill().map(()=>Array(gs).fill(0));for(let o=0;o<blocksNumber;o++){let t,s,i,a=0,l=-9e9,p=!1,r=RL(e);o>=blocksNumber-extra&&4!=features.colorScheme&&(r=RL(n,.7),fitnessFunctionNumber=6,maxTry=6,p=!0);for(let e=0;e<maxTry;e++){(i=JSON.parse(JSON.stringify(r))).color=R()*(palette.length-1|0)+1,i.color2=R()*(palette.length-1|0)+1,i.texture=4*R()|0,1==features.colorScheme&&(i.texture=0),i.symX=!0,i.rot=4*R()|0,i.type==typeEye&&(i.rot=0);let n=()=>Array(9).fill(Array(9).fill(1));i.maskBottom=i.maskBottom||n(),i.maskTop=i.maskTop||n(),i.span=[...i.size];for(let e=0;e<i.rot;e++)i.span.reverse(),i.maskBottom=rotArray(i.maskBottom),i.maskTop=rotArray(i.maskTop),i.symX=!i.symX;if(i.span[0]>gs/2){maxTry<maxMaxTry&&maxTry++;continue}i.pos=gs%2==0?[i.span[0]/2+(R()*(gs/2+1-i.span[0])|0),0,-gs/2+i.span[2]/2+(R()*(gs+1-i.span[2])|0)]:[i.span[0]/2+(R()*((gs-1)/2+1-i.span[0])|0)+.5,0,-gs/2+i.span[2]/2+(R()*(gs+1-i.span[2])|0)],i.span[0]%2==gs%2&&R()<1/(gs-i.span[0])&&(i.span[0]%2||i.symX)&&(i.pos[0]=0);let o=0,p=0,c=[...Array(i.span[0])].map((e,n)=>i.pos[0]+n-(i.span[0]-1)/2),f=[...Array(i.span[2])].map((e,n)=>i.pos[2]+n-(i.span[2]-1)/2);for(let e of c)for(let n of f)e>=0?p++:o++;let y=0,b=0,m=0,u=0;for(let e of f)for(let n of c){let o=u%i.span[0],t=floor(u/i.span[0]);u++,b=max(b,blocksHeightMap[n+gs/2-.5][e+gs/2-.5]),m=max(m,disallowedHeightMap[n+gs/2-.5][e+gs/2-.5]),1==i.maskBottom[o][t]&&(y=max(y,blocksHeightMap[n+gs/2-.5][e+gs/2-.5]))}y<m?maxTry<maxMaxTry&&maxTry++:y>b?maxTry<maxMaxTry&&maxTry++:((t=[0,-M.hypot(i.pos[0],i.pos[2]),-y,-M.hypot(i.pos[0],y-10,i.pos[2]),-abs(M.hypot(i.pos[0],y-10,i.pos[2])-gs),-abs(M.hypot(i.pos[0],2*y,i.pos[2])-gs),2*y+i.pos[2]][fitnessFunctionNumber])>l||0==e)&&(l=t,a=y,s=i)}if(s)if(s.pos[1]=a+s.size[1]/2,s.pos[1]){if(p&&s.pos[1]-s.span[1]/2==0){console.log("extra on the floor!");continue}let e=Array(s.span[0]).fill().map((e,n)=>s.pos[0]+n-(s.span[0]-1)/2),n=Array(s.span[2]).fill().map((e,n)=>s.pos[2]+n-(s.span[2]-1)/2),o=0;for(let t of n)for(let n of e){let e=o%s.span[0],i=floor(o/s.span[0]);o++,blocksHeightMap[n+gs/2-.5][t+gs/2-.5]=a+s.size[1],0==s.maskTop[e][i]&&(blocksHeightMap[n+gs/2-.5][t+gs/2-.5]=-99),disallowedHeightMap[n+gs/2-.5][t+gs/2-.5]=a+s.size[1]}blocks.push(s);for(let e=0;e++<8;){let n=[0,0,0].map((n,o)=>(e>>o&1)-.5);vertices.push([n[0]*(s.span[0]+2*s.pos[0]),n[1]*s.span[1]+s.pos[1],n[2]*s.span[2]+s.pos[2]])}features.blocksNumber++,s.type==typeEye&&features.eyes++,s.type==typePillar&&features.aerials++,s.pos[0]>0&&(features.blocksNumber++,s.type==typeEye&&features.eyes++,s.type==typePillar&&features.aerials++)}else console.log("bv.pos.y is NaN");else console.log("bv not defined")}console.log("N BLOCKS",blocks.length,"\n=============================="),console.log(blocks),features.height=M.max(...disallowedHeightMap.flat())}let findViewBox=()=>{viewBox={top:-1e9,bottom:1e9,left:1e9,right:-1e9};let e=(e,n,o)=>[e*cos(o)-n*sin(o),e*sin(o)+n*cos(o)];vertices.forEach(n=>{let[o,t,s]=n;[o,s]=e(o,s,-u_camAngXZ),[t,s]=e(t,s,-u_camAngYZ),viewBox.left=min(o,viewBox.left),viewBox.right=max(o,viewBox.right),viewBox.bottom=min(t,viewBox.bottom),viewBox.top=max(t,viewBox.top)}),viewBox.width=viewBox.right-viewBox.left,viewBox.height=viewBox.top-viewBox.bottom,viewBox.scale=max(viewBox.width/1.8,viewBox.height/1.8,1),viewBox.offset={x:viewBox.left+viewBox.width/2,y:viewBox.bottom+viewBox.height/2}};function preload(){}function setup(){let e=min(windowHeight,windowWidth);canvas=createCanvas(e,e,WEBGL),b=createGraphics(width,height,WEBGL),init(),background(palette[0]),placeBlocks(),findViewBox(),u_sizes=blocks.map(e=>e.size).flat(),u_positions=blocks.map(e=>e.pos).flat(),u_palette=palette.map(e=>color(e).levels.slice(0,3)).flat().map(e=>e/255),u_colors=blocks.map(e=>[e.color,e.color2,e.texture]).flat(),u_types=blocks.map(e=>e.type),u_rotations=blocks.map(e=>e.rot),sf=`precision highp float;\n#define BLOCKS_NUMBER_MAX 60\n#define PI 3.1415\n#define S smoothstep\n#define V vec3\n#define v vec2\n#define rnd(x) fract(54321.987 * sin(987.12345 * mod(x,12.34567)))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define STEPS 4e2\n#define EPS .001\n#define box(p,s) (length(p - clamp(p, -(s)/2., (s)/2.)) - cornerR * 1.4)\n#define sabs(p) sqrt(abs(p)*abs(p)+.00005)\n#define smax(a,b) (a+b+sabs(a-b))*.5\n\nvarying v uv;\nuniform V positions[BLOCKS_NUMBER_MAX];\nuniform V sizes[BLOCKS_NUMBER_MAX];\nuniform ivec3 colors[BLOCKS_NUMBER_MAX];\nuniform int types[BLOCKS_NUMBER_MAX];\nuniform float rotations[BLOCKS_NUMBER_MAX];\nuniform V palette[20];\nuniform sampler2D b;\nuniform float t;\n\nivec3 colIds;\nfloat gl;\nfloat camDist = 400.;\nv u_res = v(${width}, ${height})*${pixelDensity()+1e-6};\n\n\nfloat cyl(V p, V s, float cornerR) {\n    // s.x — height\n    // s.y — thickness\n    // s.x — radius\n    p.y -= clamp(p.y, -s.x, s.x);\n    float len = length(p.xz) - s.z;\n    len -= clamp(len, -s.y, s.y);\n    float cyl = length(v(len, p.y)) - cornerR;\n    return cyl;\n}\n\nv random2f() {\n    v rn = v(rnd(length(uv) - t), rnd(length(uv) - t - .1));\n    float k = .5;\n    v a;\n    a.x = .5 * pow(2.0 * ((rn.x < 0.5) ? rn.x : 1.0 - rn.x), k);\n    a.y = .5 * pow(2.0 * ((rn.y < 0.5) ? rn.y : 1.0 - rn.y), k);\n    rn.x = (rn.x < 0.5) ? a.x : 1.0 - a.x;\n    rn.y = (rn.y < 0.5) ? a.y : 1.0 - a.y;\n    return rn * 2. - 1.;\n}\n\nint eye;\n\nfloat dist(V p) {\n    colIds = ivec3(0, 0, -1);\n    p.x = abs(p.x);\n    float res = p.y + 1.; // floor plane\n    for(int i = 0; i < BLOCKS_NUMBER_MAX; i++) {\n        eye = 0;\n        if(i >= ${blocks.length})\n            break;\n        V pb = p;\n        pb -= positions[i];\n        pb.xz *= rot(rotations[i] * PI / 2.);\n\n        // box\n        float cornerR = .01;//.025;//.05;\n        float gap = .008;\n        float block;\n        if(types[i] == 0 || types[i] == 3 || types[i] == 4 || types[i] == 5 || types[i] == 6 || types[i] == 7) {\n            block = box(pb, sizes[i] - 2. * (cornerR + gap));\n        } else if(types[i] == 1) { // cyl\n            block = max(length(pb.xz) - .5, abs(pb.y) - .5);\n        } else if(types[i] == 2) { // ball\n            block = length(pb) - .52;\n        }\n\n        if(types[i] == 5) {\n            float cyl = length(pb.zy) - .5;\n            float box = max(abs(pb.z) - .5, abs(pb.y + sizes[i].y / 2.) - 1.);\n            float hole = min(cyl, box);\n            block = max(block, -hole);\n        }\n\n        if(types[i] == 6) { // pillar\n            float cyl_ = length(pb.zx) - .15;\n            float sph = cyl(pb + V(0, sizes[i].y - .5, 0) / 2., V(.2, .25, .2), cornerR);\n            // float sph = length(pb) - .45;\n            block = max(block, min(cyl_, sph));\n        }\n\n        // studs\n        if(types[i] != 6) {\n            V ps = pb;\n            v l = sizes[i].xz;\n            ps.xz += (l - 1.) / 2.;\n            ps.xz = ps.xz - clamp(floor(ps.xz + .5), v(0.), l - 1.);\n            float h = .24;\n            float stud = (${features.studs} == 1) ? abs(length(ps.xz) - .28 + .05) - .05 : length(ps.xz) - .28;\n            stud = max(stud, abs(ps.y - sizes[i].y / 2. - h / 2.) - h / 2.);\n            block = min(stud, block);\n        }\n\n        // // rounded slopes\n        // if (pb.z<0.){\n        //     if(types[i] == 3) { // beak\n        //         block=max(block, length(pb.zy+v(0,sizes[i].y/2.))-1.);\n        //     }\n        //     if(types[i] == 4) { // beak down\n        //         block=max(block, length(pb.zy-v(0,sizes[i].y/2.))-1.);\n        //     }\n        // }\n\n        // old slopes\n        // if(types[i] == 3 || types[i] == 4) { // beak\n        //     // pb.z *= -1.;\n        //     V pe = pb;\n        //     pe.z += .55;\n        //     pe.yz *= rot(PI * .26);\n        //     // if(types[i] == 3)\n        //     //     pe.yz *= rot(-PI / 2.);\n        //     block = max(block, -pe.z);\n        // }\n\n        // if(types[i] == 3 || types[i] == 4) { // beak\n        //     if (pb.z<0.){\n        //         // pb*=1.0;\n        //         float s = 1.4142;\n        //         pb.zy+=vec2(1,.5);\n        //         pb.zy*=rot(-PI/4.);\n        //         vec2 n=vec2(0,1)*rot(-PI/8.);\n        //         // vec2 n=vec2(.3827,.9238);\n        //         pb.zy-=2.*min(.0,dot(pb.zy,n))*n;\n        //         pb.zy.x-=s;\n        //         n*=rot(-PI*1.5);\n        //         pb.zy-=2.*min(.0,dot(pb.zy,n))*n;\n        //         pb.zy-=clamp(pb.zy,-s,0.);\n        //         block = max(length(pb.zy)/2., block);\n        //         // block = length(pb.zy);\n        //     }\n        // }\n\n        if(pb.z<0.15 && (types[i] == 3 || types[i] == 4)) { // beak\n            block = smax(block, (-pb.z*.8-(types[i] == 3 ? -1. : 1.)*pb.y-.5)/1.4142);\n        }\n\n\n        if(types[i] == 7) { // eye\n            // pb.z -= .5;\n            // block = box(pb - V(0, 0, .5), V(1));\n            // pb.zy *= rot(PI / 2.);\n            // pb.y+=.25;\n            float eye_ = cyl(pb, V(.2, .25, .2), cornerR);\n            block = eye_;\n            if(eye_ < EPS) {\n                // eye = int(step(.3, length(pb.xz) - length(pb.xz * 2. - v(2)) / 3.));\n                eye = 1;\n                //-int(min(step(-.3,-),step(.3,)));\n            }\n            // block = max(block, min(cyl, sph));\n        }\n\n        if(block < res) {\n            res = block;\n            colIds = colors[i];\n        }\n        if(res < EPS)\n            break;\n    }\n    return res;\n}\n\nV norm(V p) {\n    v e = v(.01, 0.);\n    return normalize(V(dist(p + e.xyy) - dist(p - e.xyy), dist(p + e.yxy) - dist(p - e.yxy), dist(p + e.yyx) - dist(p - e.yyx)));\n}\n\nvoid main() {\n    gl = 0.;\n    float d = 0., e = 1e9, ep, j;\n    v uv_ = (uv*u_res/min(u_res.x,u_res.y)) + random2f() * 1.5 / u_res;\n    V p, ro = V(uv_ * float(${viewBox.scale}) + \n    v(${viewBox.offset.x}, \n    ${viewBox.offset.y}), -camDist), \n    rd = V(0, 0, .9 + .1 * rnd(length(uv_))), o;\n    bool outline = false;\n    for(float i = 0.; i < STEPS; i++) {\n        j = i;\n        p = d * rd + ro;\n        p.z -= camDist;\n        p.yz *= rot(${u_camAngYZ});\n        p.xz *= rot(${u_camAngXZ});\n        d += e = dist(p);\n        if(ep < e && e < .01) {\n            // gl_FragColor = vec4(0);\n            outline = true;\n            break;\n        }\n        ep = e;\n        // if(colIds.x > 0) { // if not floor, glow!\n        //     // gl +=  pow(.0000001 * e, .4);\n        // }\n        if(e < EPS || e > camDist*2.)\n            break;\n    }\n    if(!outline) {\n        V col1, col2;\n        for(int j = 0; j < 20; j++) {\n            if(colIds[0] == j)\n                col1 = palette[j];\n            if(colIds[1] == j)\n                col2 = palette[j];\n        }\n\n        V col = col1;\n\n        // Texturing\n        //\n        // layers\n        if(colIds.z == 1)\n            if(sin(p.y * PI * 3.) > 0.)\n                col = col2;\n        if(colIds.z == 2)\n            if(sin((p.x + fract(positions[0].x - sizes[0].x / 2.)) * PI * 2. * 1.5) > 0.)\n                col = col2;\n\n        // pride\n        if(${features.colorScheme} == 3)\n            col = sin(length(p) / max(float(${gs}), float(${features.height})) * 6.28 * 2. - V(0, PI * 2. / 3., PI * 4. / 3.)) * .5 + .5;\n            // p*=.3;\n            // col = sin(8.*dot(sin(p), cos(p.zxy))  - V(0, PI * 2. / 3., PI * 4. / 3.)) * .5 + .5;\n\n        if(eye == 1) {\n            col = V(0);\n            V pe = p + fract(${gs}. / 2.);\n            pe = fract(pe) - .5;\n            col += step(.3, length(pe.xz));\n            col += step(-.1, -length(pe.xz + .1));\n        }\n\n        if(colIds.z == -1) {\n            o = palette[0];\n            if(length(o) > .4)\n                o *= smoothstep(5., 0., length(uv_ + v(${features.bgLight}, -1)));\n            if(${features.colorScheme} == 3)\n                // o = V(o.r*.5);\n                o = V(.2);\n            if(sin(length(pow(abs(uv_), v(${features.bgType}))) * 32.) > 0.)\n                o *= .95;\n        } else {\n            // shading\n            o = (min(1.5, 14. / j) * .2 + .8) * (dot(norm(p), normalize(V(0, 1, 1))) * .2 + .8) * col;\n            // glare\n            o += pow(dot(norm(p), normalize(V(0, 3, 1))), 40.);\n        }\n    }\n\n    // gazya\n    if(${features.colorScheme} == 4)\n        o = (V(10. / j));\n\n    gl_FragColor = mix(texture2D(b, uv * v(1, -1) * .5 + .5), vec4(o, 1), 1. / (t + 1.));\n    // gl_FragColor = vec4(o*rnd(${u_tick}), 1);\n}`,s=createShader(sv="attribute vec3 aPosition;\n    varying vec2 uv;\n    void main() {\n      vec4 positionVec4 = vec4(aPosition, 1.0);\n      uv = positionVec4.xy = positionVec4.xy * 2.0 - 1.0;\n      gl_Position = positionVec4;\n    }",sf),preloaderSize=document.querySelector("canvas").getBoundingClientRect(),console.log(preloaderSize),(preloader=document.body.appendChild(document.createElement("div"))).style.position="absolute",preloader.style.left=preloaderSize.x,preloader.style.top=preloaderSize.bottom-preloaderSize.height/100,preloader.style.height=preloaderSize.height/100,preloader.style.width=0,preloader.style.background="#fff9",loop(),console.log("features",features)}function draw(){b.clear(),b.image(canvas,-.5*width,-.5*height,width,height),clear(),shader(s),s.setUniform("b",b),s.setUniform("t",u_tick),s.setUniform("positions",u_positions),s.setUniform("sizes",u_sizes),s.setUniform("rotations",u_rotations),s.setUniform("colors",u_colors),s.setUniform("palette",u_palette),s.setUniform("types",u_types),rect(0,0,width,height),console.log(u_tick),preloader.style.width=preloaderSize.width*u_tick/50,u_tick++>50&&(preloader.remove(),noLoop())}