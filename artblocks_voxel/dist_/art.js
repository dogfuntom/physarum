let n,e,r,o,t,a;console.log(tokenData.hash);let i,l,c,p,s,f,d,b,x,g,m,u,y,v,F,h,V,z=Math,k=Array,_=z.min,$=z.max,D=z.floor,I=z.abs,j=z.cos,E=z.sin,R=devicePixelRatio,C=location.href.split("#")[1],N=n=>n[0].map((e,r)=>n.slice().reverse().map(n=>n[r])),M=0,L=3,B=4,w=5,S=6,A=7,O=30,X=.95532,P=[...Array(1e3)].map(()=>[...Array(10)].map(()=>[0,0,0])),U=()=>{n=new Uint32Array([4,1,e=o=2,3].map(n=>parseInt(tokenData.hash.substr(8*n,8),16))),r=()=>(o=n[3],n[3]=n[2],n[2]=n[1],n[1]=e=n[0],o^=o<<11,n[0]^=o^o>>>8^e>>>19,n[0]/2**32),t=(n,e)=>n[n.length*r()**(e||1)|0],a=n=>n.map(n=>[n,r()]).sort((n,e)=>n[1]-e[1]).map(n=>n[0]),y=[],u_tick=1e-6,x=[r()**4*2|0,r()**8*2|0,0,5*(1-r()**.3)|0,0,t([2,1],.5),(3*r()|0)-1,0,0,0,0],i=(x[0]-.5)*z.PI/2-z.PI;let g=[[8+2*r()|0,30,5,8,0],[4,3+4*r()|0,0,1,1],[8+2*r()|0,30,3,8,r()**4*8],[6+4*r()|0,10+20*r()|0,2,6,2*r()],[6+(0|r()),10+10*r()|0,0,4,r()**2*3]];x[4]=z.sqrt(1-(r()-1)**2)*g.length|0,[p,s,f,d,b]=g[x[4]],l=2+2*r()|0,u=[],x[2]=r()**.5*8|0,c="dddddd888888555555222222aaaaaaf26b21fbb04099ca3c208b3afcec529b5de5f15bb500bbf900f5d4fee440f1faeea8dadc457b9d1d3557e6394650514ff25f5c247ba070c1b3ffe066541388d90368f1e9da2e294effd4001f20414b3f72119da419647effc857540d6eee4266f3fcf01f271bffd23fe4572e29335ca8c686669bbcf3a712".substr(30*x[2],30).match(/(.{2})/g).map(n=>Number("0x"+n)),F=4*r()|0},K=()=>{let n=a([[[2,1,2],[[0,1],[0,1]],0,L],[[2,1,2],0,[[0,1],[0,1]],B],[[2,1,4],0,0,M],[[2,1,3],0,0,M],[[1,1,6],0,0,M],[[1,2,3],0,[[1,0,1]],w],[[1,1,3],0,0,M],[[2,1,2],0,0,M],[[1,1,1],0,0,M],[[1,2,1],0,0,M]].filter(n=>n[0][2]<p)).slice(0,l),e=a([[[1,4,1],[[0]],0,S],[[1,.5,1],[[0]],0,A]]);g=[...k(p)].map(()=>k(p).fill(0)),m=[...k(p)].map(()=>k(p).fill(0));for(let o=0;o<s;o++){let a,i,l,c=0,v=-9e9,F=0,h=t(n);o>=s-b&&4!=x[3]&&(h=t(e,.7),f=6,d=6,F=1);for(let n=0;n<d;n++){l=JSON.parse(JSON.stringify(h)),l[4]=4*r()+1|0,l[5]=4*r()+1|0,2==x[3]&&(l[4]=l[5]=1),l[6]=4*r()|0,1==x[3]&&(l[6]=0),l[7]=1,l[8]=4*r()|0,l[3]==A&&(l[8]=0);let e=()=>k(9).fill(k(9).fill(1));l[2]=l[2]||e(),l[1]=l[1]||e(),l[9]=[...l[0]];for(let n=0;n<l[8];n++)l[9].reverse(),l[2]=N(l[2]),l[1]=N(l[1]),l[7]=!l[7];if(l[9][0]>p/2){d<O&&d++;continue}l[10]=p%2==0?[l[9][0]/2+(r()*(p/2+1-l[9][0])|0),0,-p/2+l[9][2]/2+(r()*(p+1-l[9][2])|0)]:[l[9][0]/2+(r()*((p-1)/2+1-l[9][0])|0)+.5,0,-p/2+l[9][2]/2+(r()*(p+1-l[9][2])|0)],l[9][0]%2==p%2&&r()<1/(p-l[9][0])&&(l[9][0]%2||l[7])&&(l[10][0]=0);let o=0,t=0,s=[...k(l[9][0])].map((n,e)=>l[10][0]+e-(l[9][0]-1)/2),b=[...k(l[9][2])].map((n,e)=>l[10][2]+e-(l[9][2]-1)/2);for(let n of s)for(let e of b)n>=0?t++:o++;let u=0,y=0,F=0,V=0;for(let n of b)for(let e of s){let r=V%l[9][0],o=D(V/l[9][0]);V++,y=$(y,g[e+p/2-.5][n+p/2-.5]),F=$(F,m[e+p/2-.5][n+p/2-.5]),1==l[2][r][o]&&(u=$(u,g[e+p/2-.5][n+p/2-.5]))}u<F||u>y?d<O&&d++:(a=[0,-z.hypot(l[10][0],l[10][2]),-u,-z.hypot(l[10][0],u-10,l[10][2]),-I(z.hypot(l[10][0],u-10,l[10][2])-p),-I(z.hypot(l[10][0],2*u,l[10][2])-p),2*u+l[10][2]][f],(a>v||0==n)&&(v=a,c=u,i=l))}if(i&&(i[10][1]=c+i[0][1]/2,i[10][1])){if(F&&i[10][1]-i[9][1]/2==0)continue;let n=k(i[9][0]).fill().map((n,e)=>i[10][0]+e-(i[9][0]-1)/2),e=k(i[9][2]).fill().map((n,e)=>i[10][2]+e-(i[9][2]-1)/2),r=0;for(let o of e)for(let e of n){let n=r%i[9][0],t=D(r/i[9][0]);r++,g[e+p/2-.5][o+p/2-.5]=c+i[0][1],0==i[1][n][t]&&(g[e+p/2-.5][o+p/2-.5]=-99),m[e+p/2-.5][o+p/2-.5]=c+i[0][1]}u.push(i);for(let n=0;n<i[9][0];n++)for(let e=0;e<i[9][1];e++)for(let r=0;r<i[9][2];r++){let o=i[10][0]-i[9][0]/2+n+5|0,t=i[10][1]-i[9][1]/2+e|0,a=i[10][2]-i[9][2]/2+r+5|0;P[a+10*t][o][0]=P[a+10*t+10][o][1]=255*(u.length+1)/64}for(let n=0;n++<8;){let e=[0,0,0].map((e,r)=>(n>>r&1)-.5);y.push([e[0]*(i[9][0]+2*i[10][0]),e[1]*i[9][1]+i[10][1],e[2]*i[9][2]+i[10][2]])}}}},G=()=>{v=[-99,99,99,-99];let n=(n,e,r)=>[n*j(r)-e*E(r),n*E(r)+e*j(r)];y.forEach(e=>{let[r,o,t]=e;[r,t]=n(r,t,-i),[o,t]=n(o,t,-X),v[2]=_(r,v[2]),v[3]=$(r,v[3]),v[1]=_(o,v[1]),v[0]=$(o,v[0])}),v[4]=v[3]-v[2],v[5]=v[0]-v[1],v[6]=$(v[4]/1.8,v[5]/1.8,1),v[7]=v[2]+v[4]/2,v[8]=v[1]+v[5]/2};U(),K(),G(),console.log(c),u_colors=u.map(n=>[n[4],n[5],n[6]]).flat();let q="";q+=u.map((n,e)=>`ps[${e}]=vec3(${n[10][0]},${n[10][1]},${n[10][2]});`).join(""),q+=u.map((n,e)=>`ss[${e}]=vec3(${n[0][0]},${n[0][1]},${n[0][2]});`).join(""),q+=u.map((n,e)=>`cs[${e}]=ivec3(${n[4]},${n[5]},${n[6]});`).join(""),q+=u.map((n,e)=>`rt[${e}]=vec2(${n[8]},${n[3]});`).join("");let T=z.min(innerWidth,innerHeight)*R,W=document.createElement("canvas");W.style.width=T/R+"px",W.style.height=T/R+"px",T=_(T,2048);let H=W.getContext("webgl",{preserveDrawingBuffer:!0});document.body.appendChild(W);let J=c.slice(3*F,3+3*F);W.style.background=4==x[3]||3==x[3]?"#333":`rgb(${J})`,W.width=T,W.height=T;let Y=createREGL({gl:H,extensions:["webgl_draw_buffers","oes_texture_float"]}),Q=Y.texture(P),Z=[z.random(),z.random(),z.random()],nn=[z.random(),z.random(),z.random()];console.log("light1, light2",Z,nn),Z=[0,1,.5];let en=Y.framebuffer({color:[Y.texture({type:"float",width:T,height:T}),Y.texture({type:"float",width:T,height:T})],depth:!1}),rn=Y.framebuffer({color:[Y.texture({type:"float"}),Y.texture({type:"float"})],depth:!1}),on={frag:`#extension GL_EXT_draw_buffers : require\n                precision highp float;\n                #define BLOCKS_NUMBER_MAX 60\n                #define PI 3.1415\n                #define S smoothstep\n                #define V vec3\n                #define F float\n                #define N normalize\n                #define L length\n                #define v vec2\n                mat2 rot(F a) {→mat2(cos(a),-sin(a),sin(a),cos(a));} // FIXME\n                #define rnd(x) fract(54321.987 * sin(987.12345 * x + .1))\n                // #define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n                #define EPS .0001\n                F sabs(F p) {→sqrt(abs(p)*abs(p)+5e-5);}\n                F smax(F a, F b) {→(a+b+sabs(a-b))*.5;}\n                \n                V ps[BLOCKS_NUMBER_MAX];\n                V ss[BLOCKS_NUMBER_MAX];\n                v rt[BLOCKS_NUMBER_MAX];\n                ivec3 cs[BLOCKS_NUMBER_MAX];\n                \n                uniform V pt[5];\n                uniform F aa;\n                uniform F rs;\n                uniform F render;\n\n                uniform sampler2D tex3d;\n                uniform sampler2D texCol;\n                uniform sampler2D texNorm;\n        \n                ivec3 colIds = ivec3(0);\n                F gl;\n                F camDist = 30.;\n                ivec2 blockId;\n                F cornerR = .01, gap = .015, block;\n                F outlineWidth = .015;//((cornerR+gap)*sqrt(2.) - cornerR);\n                \n                // int eye = 0;\n                // V eye = V(0.);\n                // eye = 0;\n    \n                F tube(V p, V s){\n                    v po = v(L(p.xz), p.y - clamp(p.y, EPS, s.x));\n                    po.x -= clamp(po.x, s.z, s.y);\n                    →L(po)-EPS;\n                }\n                \n                F dist(V p) {\n                    // return max(length(p.xz)-.4,abs(p.y)-.9);\n                    // return length(p)-.6;\n\n                    // →length(fract(p)-.5)-.5;\n                    p.x = abs(p.x);\n                    // F res = 1e5;\n                    F res = p.y + 1.; // floor plane\n                    // F res = length(p)-.5; // floor plane\n                    for(int i = 0; i < BLOCKS_NUMBER_MAX; i++) {\n                        if(i >= ${u.length})\n                            break;\n                        if(i != blockId.x - 1 && i != blockId.y - 1)\n                        // if(i != blockId.y - 1)\n                            continue;\n                        V pb = p;\n                        pb -= ps[i];\n                        pb.xz *= rot(rt[i].x * PI / 2.);\n                        \n                        // box\n                        // F cornerR = .01, gap = .008, block;\n                        \n                        V s = ss[i] - 2. * (cornerR + gap);\n                        block = L(pb - clamp(pb, -s/2., s/2.)) - cornerR * 1.4;\n                        // if(blockId==0) {colIds = ivec3(3, 2, 1); return length(fract(p)-.5)-.45;}\n                            \n                        if(rt[i].y == 5.) { // arc\n                            F cyl = L(pb.zy) - .5;\n                            F box = max(abs(pb.z) - .5, abs(pb.y + ss[i].y / 2.) - 1.);\n                            F hole = min(cyl, box);\n                            block = max(block, -hole);\n                        }\n    \n                        if(rt[i].y == 6.) { // pillar\n                            F narrow = tube(pb+V(0,1.6-cornerR*3.,0),V(3.55,.15,0));\n                            F base = tube(pb+V(0,2.-cornerR*2.,0),V(.4-cornerR*2.,.45,0));\n                            block = min(narrow, base);\n                            // // F narrow = tube(pb+V(0,1.6-cornerR-gap,0),V(3.55,.15,0));\n                            // F narrow = tube(pb+V(0,4./2.-.4-cornerR*2.-gap,0),V(3.55,.15-cornerR,0));\n                            // F base = tube(pb+V(0,2.-cornerR*2.,0),V(.4-cornerR*2.-gap,.45,0));\n                            // block = min(narrow, base)-cornerR;\n                        }\n\n                        // studs\n                        if(rt[i].y != 6.) { // not pillar\n                            V ps = pb;\n                            // repetition\n                            v l = ss[i].xz;\n                            ps.xz += (l - 1.) / 2.;\n                            ps.xz = ps.xz - clamp(floor(ps.xz + .5), v(0.), l - 1.);\n                            \n                            // position\n                            ps.y -= ss[i].y / 2. + .02;\n    \n                            F stud = tube(ps, V(.24, .28, mix(EPS,.18,${x[1]}.)));\n                            block = min(stud, block);\n                        }\n                \n                        if(pb.z<.01 && (rt[i].y == 3. || rt[i].y == 4.)) { // beak\n                            block = smax(block,dot(pb,V(0,.78*(7.-2.*rt[i].y),-.624))-.39);\n                        }\n                \n                \n                \n                        if(rt[i].y == 7.) { // eye\n                            // F eye_ = cyl(pb, V(.2, .25, .2), cornerR);\n                            F eye_ = tube(pb+V(0,.25-cornerR*2.,0),V(.4-cornerR*2.,.45,0));\n                            block = eye_;\n                            if(eye_ < EPS) {\n                                colIds.z = 9; // eye\n                                // discard;\n                                // return block;\n                            }\n                        }\n                \n                        // block = L(pb)-2.;\n                        if(block < res) {\n                            if(colIds.z == 9)// FIXME как-то эти ифы упростить, они нужны только чтобы глаза работали.\n                                colIds = ivec3(cs[i].xy, 9);\n                            else\n                                colIds = cs[i];\n                            res = block;\n                        }\n                        if(res < EPS)\n                            break;\n                    }\n                    →res;\n                }\n                \n                V norm(V p) {\n                    // p+=.5;\n                    // →normalize(fract(p));\n                    v e = v(.01, 0.);\n                    →N(V(dist(p + e.xyy) - dist(p - e.xyy), dist(p + e.yxy) - dist(p - e.yxy), dist(p + e.yyx) - dist(p - e.yyx)));\n                }\n\n                vec2 sdfVoxel(vec3 p){\n                    p.xz += fract(float(${p/2}));  // ODD\n                    // p.xz = p.zx;\n                    p.x = abs(p.x);\n                    p.zx -= fract(float(${p/2})); // ODD\n                    // p.x += ${p}.-1.;\n                    // p.z += ${p}.;\n                    p.x += 5.;\n                    p.z += 5.;\n                    p = floor(p+vec3(0,0,.0));\n                    if(p.y < 0.) return v(0);\n                    // p.x -= .5;\n                    // p.z -= .5;\n                    vec3 boundingBox = vec3(10,1000 / 10,10);\n                    if(fract(p/boundingBox) != p/boundingBox) return -v(1.);\n                    vec2 vox, texSize = vec2(boundingBox.x, boundingBox.y*boundingBox.z);\n                    vox.x = p.x;\n                    vox.y = p.z + p.y * 10.; // FIXME\n                    vec2 voxN = (vox+.5) / texSize;\n                    blockId = ivec2(texture2D(tex3d, voxN).rg * 64.);\n                    // if(blockId == 2) discard;\n                    return vec2(blockId); // is full\n                }\n\n                void main() {\n                    if(render == 1.){\n                        gl_FragData[0] = texture2D(texCol, gl_FragCoord.xy/rs);\n                        V norm = texture2D(texNorm, gl_FragCoord.xy/rs).rgb;\n                        norm.z = -norm.z;\n                        // norm.xz *= rot(${i});\n                        // norm.yz *= rot(${X});\n                        // gl_FragData[0].rgb=norm;\n                        // gl_FragData[0].a=1.;\n                        // return;\n                        F dist = texture2D(texNorm, gl_FragCoord.xy/rs).a;\n                        if(dist>camDist*2.) return;\n                        // gl_FragData[0] *= smoothstep(35.,15.,texture2D(texNorm, gl_FragCoord.xy/rs).a);\n                        vec3 f = -V(norm.x,-norm.y,norm.z);\n                        vec3 r = cross(vec3(1,0,0), f);\n                        vec3 u = cross(f, r);\n                        for(float i=0.; i<10.; i++){\n                            V kernel = V(0,0,0);\n                            kernel += (rnd(i+length(gl_FragCoord/1000.+1.)+dist)*2.-1.) * r;\n                            kernel += (rnd(i+length(gl_FragCoord/1000.+1.)+dist+.1)*2.-1.) * u;\n                            kernel += (rnd(i+length(gl_FragCoord/1000.+1.)+dist+.2)) * f;\n                            // kernel *= rnd(i+dist+.3);\n                            vec3 offset = V(dot(kernel,vec3(1,0,0)), dot(kernel,vec3(0,1,0)), dot(kernel,V(0,0,-1)));\n\n                            // if(dist > texture2D(texNorm, gl_FragCoord.xy/rs + .1 * (vec2(rnd(i),rnd(i+.1))-.5)).a)\n                            F rad = .4;\n                            if(dist + offset.z * rad > texture2D(texNorm, gl_FragCoord.xy/rs + rad * offset.xy).a)\n                                gl_FragData[0]*=.9;\n                        }\n                        gl_FragData[0].a = 1.;\n                        return;\n                    }\n                    // gl_FragData[0] = vec4(1);\n                    \n                    // // DEBUG\n                    // vec2 uv = (gl_FragCoord.xy * 2. - rs) / rs;\n                    // V ro = V(uv * F(${v[6]}) +\n                    //     v(${v[7]},\n                    //     ${v[8]}), -camDist),\n                    //    rd = V(0, 0, 1);\n                    //    ro.yz *= rot(${X});\n                    //    rd.yz *= rot(${X});\n                    //    ro.xz *= rot(${i});\n                    //    rd.xz *= rot(${i});                float d,e=1.,j;\n                    // vec3 p;\n                    // for(float i=0.;i<99.;i++){\n                    //     j=i;\n                    //     p=ro+rd*d;\n                    //     p.z-=1.;\n                    //     p.xz = fract(p.xz)-.5;\n                    //     d+=e=dist(p);\n                    //     if(e<1e-3)break;\n                    // }\n                    // gl_FragData[0] = vec4(step(-40.,-d));\n                    // gl_FragData[1] = vec4(normalize(norm(p)),d);\n                    // return;\n                    // // END OF DEBUG\n\n\n                    ${q}\n                    V o = V(0), nnn;\n                    v uv, uvI = (gl_FragCoord.xy * 2. - rs)/rs;\n                    F d;\n        \n                    for(F A = 0.; A < 8.; A++){\n                        if(A >= aa) break;\n                        gl = 0.;\n                        F e = 1e9, ep=9., j; // here highp\n                        d = 0.;\n        \n                        F fl = floor(A/2.);\n                        F fr = mod(A,2.);\n                        v pos = v(fr/2.,fl/4.)-.5;\n                        if(mod(fl, 2.)==0.) pos.x += .25; //https://bit.ly/30g2DXs\n        \n                        v uv = uvI;\n    \n                        uv += pos * 2. / rs;\n        \n                        V n, p, ro = V(uv * F(${v[6]}) +\n                        // V n, p, ro = V(uv * 4. * F(${v[6]}) + // FIXME remore * 4.\n                            v(${v[7]},\n                            ${v[8]}), -camDist),\n                        //    rd = V(0, 0, .9 + .1 * fract(1e3 * sin(1e3 * fract(L(uv)))));\n                           rd = V(0, 0, 1);\n                        bool outline = false;\n\n                        // RAYMARCH\n\n                        // TODO ro, rd\n\n                        // MY LEGO VERSION\n                        // for(F i = 0.; i < 1e2; i++) {\n                        //     j = i;\n                        //     p = d * rd + ro;\n                        //     p.z -= camDist;\n                        //     p.yz *= rot(${X});\n                        //     p.xz *= rot(${i}); // FIXME не каждый шаг реймарша вычислять этот угол, предварительно RD повернуть и всё\n\n                        //     d += e = dist(p);\n                        //     if(ep < e && e < .01) {\n                        //         outline = true;\n                        //         break;\n                        //     }\n                        //     ep = e;\n                        //     if(e < EPS || e > camDist*2.)\n                        //         break;\n                        // }\n\n                        // vec3 ro = vec3(0,0,-10);\n                        // vec3 rd = vec3(0,0,-10);\n                        ro.yz *= rot(${X});\n                        rd.yz *= rot(${X});\n                        ro.xz *= rot(${i});\n                        rd.xz *= rot(${i});\n                        float jj = 0.;\n                        for(float i = 0.; i < 200.; i++) {\n                            jj++;\n                            p = ro + rd * d;\n                            p.xz -= fract(float(${p/2})); // ODD\n                            vec3 dp = (step(0., rd) - fract(p)) / rd;\n                            float dpmin;\n                \n                            dpmin = min(min(dp.x,dp.y),dp.z) + 1e-4;\n                \n                            bool breaker = false;\n                            if(length(sdfVoxel(p)) > 0.) {\n                                float ddd = 0.;\n                                for(float backupI = 0.; backupI < 200.; backupI++) { // FIXME get rid of backupI\n                                    jj++;\n                                    p = ro + rd * (d + ddd);\n                                    ddd += e = dist(p);\n                                    // if(e < .001 || ++i > 200.) { // FIXME restore this i++ condition\n                                    if(ep < e && e < outlineWidth) {\n                                        outline = true;\n                                        break;\n                                    }\n                                    ep = e;\n                                    if(e < .001 || jj > 200. || d > camDist*2.) { // налетели на сферу\n                                        // if(id > 0.)\n                                        //     col *= color(id);\n                                            // col *= n+.5;\n                                        // if(s > 1.)\n                                            // col *= .6;\n                                        breaker = true;\n                                        dpmin = ddd;\n                                        break;\n                                    }\n                                    if(ddd > dpmin) { // улетели в соседнюю клетку\n                                        break;\n                                    }\n                                }\n                            }\n                            else\n                                colIds = ivec3(0, 0, -1);\n                                d += dpmin;\n                                if(breaker == true || jj > 200.)\n                                break;\n                                \n                        }\n\n                        V c;\n                        if(!outline) {\n                            V col1, col2;\n                            for(int j = 0; j < 5; j++) {\n                                if(colIds[0] == j)\n                                col1 = pt[j];\n                                if(colIds[1] == j)\n                                col2 = pt[j];\n                            }\n                            \n                            V col = col1;\n                            \n                            // Texturing\n                            //\n                            // layers\n                            if(colIds.z == 1)\n                            if(sin(p.y * PI * 3.) > 0.)\n                            col = col2;\n                            if(colIds.z == 2)\n                            if(sin((p.x + fract(ps[0].x - ss[0].x / 2.)) * PI * 2. * 1.5) > 0.)\n                            col = col2;\n                            \n                            // pride\n                            if(${x[3]} == 3)\n                            col = sin((L(p) / max(F(${p}), F(${x[8]})) * 2. - V(0, .3, .6)) * 6.28) * .5 + .5;\n\n                            nnn = norm(p); // надо тут вычислять, видимо, где-то выше я сбиваю colIds выполняя дист\n                            // иначе colIds.z равен 0 с чего-то. Но почему тогда dist(p); не помогает?\n                            if(colIds.z == 9) {\n                                col = V(0);\n                                V pe = p + fract(${p}. / 2.);\n                                pe = fract(pe) - .5;\n                                col += step(.3, L(pe.xz));\n                                col += step(-.1, -L(pe.xz + .1));\n                            }\n                        \n                            if(colIds.z == -1) {\n                                // // фончик\n                                // c = texture2D(tex3d,gl_FragCoord.xy / rs).rgb;\n                                \n                                c = V(${J})/255.;\n                                if(L(c) > .4){\n                                    c *= S(5., 0., L(uv + v(${x[6]}, -1)));\n                                }\n                                // c = V(1,0,1);\n                                if(${x[3]} == 3){\n                                    c = V(.2);\n                                }\n                                if(sin(L(pow(abs(uv), v(${x[5]}))) * 32.) > 0.)\n                                c *= .95;\n                            } else {\n                                // c = V(1,0,1);\n                                // shading\n                                c = col;\n                                c *= min(1.5, 55. / jj) * .2 + .8;\n                                c *= dot(nnn, N(V(-.5,.5,0))) * .2 + 1.;\n\n                                // glare\n                                if(colIds.z!=9)\n                                    c += pow(abs(dot(nnn, N(V(0, 1.5, .5)))), 40.);\n                            }\n                            // gazya\n                            if(${x[3]} == 4) // FIXME газю выпилиииить :-(\n                                c = (V(20. / jj));\n                        }\n                        // n = norm(p);\n                        // c = n;\n                        // // texture debug\n                        // c.g = fract(gl_FragCoord.y / rs * 11.);\n                        // c.g *= pow(fract(gl_FragCoord.y / rs * 1000.),8.);// * fract(gl_FragCoord.x / rs * 10.);\n                        // c.g += step(0.001,texture2D(tex3d, gl_FragCoord.xy / rs).r) * 8.;\n                        // c *= 30./jj;\n\n                        o += c;\n                    }\n                    gl_FragData[0] = vec4(o/aa,1);\n                    gl_FragData[1] = vec4(nnn/aa,d);\n                    // gl_FragData[1] = vec4(0,0,1,1);\n                    // return;\n                }`.replace(/@/g,"\n#define ").replace(/→/g,"return "),vert:"attribute vec2 g;void main(){gl_Position=vec4(g,0,1);}",attributes:{g:[[1,1],[1,-4],[-4,1]]},uniforms:{rs:Y.prop("r"),pt:c.map(n=>n/255),aa:Y.prop("a"),tex3d:Q,texCol:rn.color[0],texNorm:rn.color[1],render:0},scissor:{enable:!0,box:{x:Y.prop("x"),y:Y.prop("y"),width:Y.prop("t"),height:Y.prop("t")}},depth:{enable:!1},framebuffer:en,count:3},tn=Y(on),an=1+(T/V|0),ln=0,cn=new Date,pn=1,sn=1;C&&(sn=Number(C));let fn=1;V=256,tn({r:T,x:0,y:0,t:T,a:8}),on.framebuffer=null,on.uniforms.render=1,on.uniforms.texCol=en.color[0],on.uniforms.texNorm=en.color[1];let dn=Y(on);dn({r:T,x:0,y:0,t:T,a:1});'tx shvembldr piter stranger'