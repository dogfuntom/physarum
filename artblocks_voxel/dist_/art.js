let n,e,o,r,t,i;console.log(tokenData.hash);let a,l,p,s,c,f,d,b,m,y,x,u,v,g,h,V,F,$=Math,k=Array,z=$.min,I=$.max,_=$.floor,E=$.abs,L=$.cos,R=$.sin,A=devicePixelRatio,M=location.href.split("#")[1],S=n=>n[0].map((e,o)=>n.slice().reverse().map(n=>n[o])),j=0,N=3,P=4,D=5,B=6,w=7,C=30,O=.95532,X=()=>{n=new Uint32Array([4,1,e=r=2,3].map(n=>parseInt(tokenData.hash.substr(8*n,8),16))),o=()=>(r=n[3],n[3]=n[2],n[2]=n[1],n[1]=e=n[0],r^=r<<11,n[0]^=r^r>>>8^e>>>19,n[0]/2**32),t=(n,e)=>n[n.length*o()**(e||1)|0],i=n=>n.map(n=>[n,o()]).sort((n,e)=>n[1]-e[1]).map(n=>n[0]),v=[],u_tick=1e-6,m=[o()**4*2|0,o()**8*2|0,0,5*(1-o()**.3)|0,0,t([2,1],.5),(3*o()|0)-1,0,0,0,0],a=(m[0]-.5)*$.PI/2-$.PI;let y=[[8+2*o()|0,30,5,8,0],[4,3+4*o()|0,0,1,1],[8+2*o()|0,30,3,8,o()**4*8],[6+4*o()|0,10+20*o()|0,2,6,2*o()],[6+(0|o()),10+10*o()|0,0,4,o()**2*3]];m[4]=$.sqrt(1-(o()-1)**2)*y.length|0,[s,c,f,d,b]=y[m[4]],l=2+2*o()|0,u=[],m[2]=o()**.5*8|0,p="dddddd888888555555222222aaaaaaf26b21fbb04099ca3c208b3afcec529b5de5f15bb500bbf900f5d4fee440f1faeea8dadc457b9d1d3557e6394650514ff25f5c247ba070c1b3ffe066541388d90368f1e9da2e294effd4001f20414b3f72119da419647effc857540d6eee4266f3fcf01f271bffd23fe4572e29335ca8c686669bbcf3a712".substr(30*m[2],30).match(/(.{2})/g).map(n=>Number("0x"+n)),h=4*o()|0},U=()=>{let n=i([[[2,1,2],[[0,1],[0,1]],0,N],[[2,1,2],0,[[0,1],[0,1]],P],[[2,1,4],0,0,j],[[2,1,3],0,0,j],[[1,1,6],0,0,j],[[1,2,3],0,[[1,0,1]],D],[[1,1,3],0,0,j],[[2,1,2],0,0,j],[[1,1,1],0,0,j],[[1,2,1],0,0,j]].filter(n=>n[0][2]<s)).slice(0,l),e=i([[[1,4,1],[[0]],0,B],[[1,.5,1],[[0]],0,w]]);y=[...k(s)].map(()=>k(s).fill(0)),x=[...k(s)].map(()=>k(s).fill(0));for(let r=0;r<c;r++){let i,a,l,p=0,g=-9e9,h=0,V=t(n);r>=c-b&&4!=m[3]&&(V=t(e,.7),f=6,d=6,h=1);for(let n=0;n<d;n++){l=JSON.parse(JSON.stringify(V)),l[4]=4*o()+1|0,l[5]=4*o()+1|0,2==m[3]&&(l[4]=l[5]=1),l[6]=4*o()|0,1==m[3]&&(l[6]=0),l[7]=1,l[8]=4*o()|0,l[3]==w&&(l[8]=0);let e=()=>k(9).fill(k(9).fill(1));l[2]=l[2]||e(),l[1]=l[1]||e(),l[9]=[...l[0]];for(let n=0;n<l[8];n++)l[9].reverse(),l[2]=S(l[2]),l[1]=S(l[1]),l[7]=!l[7];if(l[9][0]>s/2){d<C&&d++;continue}l[10]=s%2==0?[l[9][0]/2+(o()*(s/2+1-l[9][0])|0),0,-s/2+l[9][2]/2+(o()*(s+1-l[9][2])|0)]:[l[9][0]/2+(o()*((s-1)/2+1-l[9][0])|0)+.5,0,-s/2+l[9][2]/2+(o()*(s+1-l[9][2])|0)],l[9][0]%2==s%2&&o()<1/(s-l[9][0])&&(l[9][0]%2||l[7])&&(l[10][0]=0);let r=0,t=0,c=[...k(l[9][0])].map((n,e)=>l[10][0]+e-(l[9][0]-1)/2),b=[...k(l[9][2])].map((n,e)=>l[10][2]+e-(l[9][2]-1)/2);for(let n of c)for(let e of b)n>=0?t++:r++;let u=0,v=0,h=0,F=0;for(let n of b)for(let e of c){let o=F%l[9][0],r=_(F/l[9][0]);F++,v=I(v,y[e+s/2-.5][n+s/2-.5]),h=I(h,x[e+s/2-.5][n+s/2-.5]),1==l[2][o][r]&&(u=I(u,y[e+s/2-.5][n+s/2-.5]))}u<h||u>v?d<C&&d++:(i=[0,-$.hypot(l[10][0],l[10][2]),-u,-$.hypot(l[10][0],u-10,l[10][2]),-E($.hypot(l[10][0],u-10,l[10][2])-s),-E($.hypot(l[10][0],2*u,l[10][2])-s),2*u+l[10][2]][f],(i>g||0==n)&&(g=i,p=u,a=l))}if(a&&(a[10][1]=p+a[0][1]/2,a[10][1])){if(h&&a[10][1]-a[9][1]/2==0)continue;let n=k(a[9][0]).fill().map((n,e)=>a[10][0]+e-(a[9][0]-1)/2),e=k(a[9][2]).fill().map((n,e)=>a[10][2]+e-(a[9][2]-1)/2),o=0;for(let r of e)for(let e of n){let n=o%a[9][0],t=_(o/a[9][0]);o++,y[e+s/2-.5][r+s/2-.5]=p+a[0][1],0==a[1][n][t]&&(y[e+s/2-.5][r+s/2-.5]=-99),x[e+s/2-.5][r+s/2-.5]=p+a[0][1]}u.push(a);for(let n=0;n++<8;){let e=[0,0,0].map((e,o)=>(n>>o&1)-.5);v.push([e[0]*(a[9][0]+2*a[10][0]),e[1]*a[9][1]+a[10][1],e[2]*a[9][2]+a[10][2]])}}}},K=()=>{g=[-99,99,99,-99];let n=(n,e,o)=>[n*L(o)-e*R(o),n*R(o)+e*L(o)];v.forEach(e=>{let[o,r,t]=e;[o,t]=n(o,t,-a),[r,t]=n(r,t,-O),g[2]=z(o,g[2]),g[3]=I(o,g[3]),g[1]=z(r,g[1]),g[0]=I(r,g[0])}),g[4]=g[3]-g[2],g[5]=g[0]-g[1],g[6]=I(g[4]/1.8,g[5]/1.8,1),g[7]=g[2]+g[4]/2,g[8]=g[1]+g[5]/2};X(),U(),K(),console.log(p),u_colors=u.map(n=>[n[4],n[5],n[6]]).flat();let q="";q+=u.map((n,e)=>`ps[${e}]=vec3(${n[10][0]},${n[10][1]},${n[10][2]});`).join(""),q+=u.map((n,e)=>`ss[${e}]=vec3(${n[0][0]},${n[0][1]},${n[0][2]});`).join(""),q+=u.map((n,e)=>`cs[${e}]=ivec3(${n[4]},${n[5]},${n[6]});`).join(""),q+=u.map((n,e)=>`rt[${e}]=vec2(${n[8]},${n[3]});`).join("");let G=$.min(innerWidth,innerHeight)*A,H=document.createElement("canvas");H.style.width=G/A+"px",H.style.height=G/A+"px",G=z(G,2048);let J=H.getContext("webgl",{preserveDrawingBuffer:!0});document.body.appendChild(H);let T=p.slice(3*h,3+3*h);H.style.background=4==m[3]||3==m[3]?"#333":`rgb(${T})`,H.width=G,H.height=G;let Y=16;var W=createREGL(J);let Q=[...Array(300)].map(()=>[...Array(10)].map(()=>[...Array(1)].map(()=>255*Math.random())));console.log(Q);let Z=W.texture(Q),nn=W({frag:`precision highp float;\n                #define BLOCKS_NUMBER_MAX 60\n                #define PI 3.1415\n                #define S smoothstep\n                #define V vec3\n                #define F float\n                #define N normalize\n                #define L length\n                #define v vec2\n                mat2 rot(F a) {→mat2(cos(a),-sin(a),sin(a),cos(a));} // FIXME\n                // #define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n                #define EPS .001\n                F sabs(F p) {→sqrt(abs(p)*abs(p)+5e-5);}\n                F smax(F a, F b) {→(a+b+sabs(a-b))*.5;}\n                \n                V ps[BLOCKS_NUMBER_MAX];\n                V ss[BLOCKS_NUMBER_MAX];\n                v rt[BLOCKS_NUMBER_MAX];\n                ivec3 cs[BLOCKS_NUMBER_MAX];\n                \n                uniform V pt[5];\n                uniform F aa;\n                uniform F rs;\n\n                uniform sampler2D tex3d;\n        \n                ivec3 colIds;\n                F gl;\n                F camDist = 2e1;\n                \n                int eye;\n    \n                F tube(V p, V s){\n                    v po = v(L(p.xz), p.y - clamp(p.y, EPS, s.x));\n                    po.x -= clamp(po.x, s.z, s.y);\n                    →L(po)-EPS;\n                }\n                \n                F dist(V p) {\n                    →length(p)-.5;\n                    // colIds = ivec3(0, 0, -1);\n                    // p.x = abs(p.x);\n                    // // F res = 1e5;\n                    // F res = p.y + 1.; // floor plane\n                    // for(int i = 0; i < BLOCKS_NUMBER_MAX; i++) {\n                    //     if(i >= ${u.length})\n                    //         break;\n                    //     eye = 0;\n                    //     V pb = p;\n                    //     pb -= ps[i];\n                    //     pb.xz *= rot(rt[i].x * PI / 2.);\n                \n                    //     // box\n                    //     F cornerR = .01, gap = .008, block;\n            \n                    //     V s = ss[i] - 2. * (cornerR + gap);\n                    //     block = L(pb - clamp(pb, -s/2., s/2.)) - cornerR * 1.4;\n                \n                    //     if(rt[i].y == 5.) { // arc\n                    //         F cyl = L(pb.zy) - .5;\n                    //         F box = max(abs(pb.z) - .5, abs(pb.y + ss[i].y / 2.) - 1.);\n                    //         F hole = min(cyl, box);\n                    //         block = max(block, -hole);\n                    //     }\n    \n                    //     if(rt[i].y == 6.) { // pillar\n                    //         F narrow = tube(pb+V(0,1.6-cornerR*2.,0),V(3.55,.15,0));\n                    //         F base = tube(pb+V(0,2.-cornerR*2.,0),V(.4-cornerR*2.,.45,0));\n                    //         block = min(narrow, base);\n                    //     }\n\n                    //     // studs\n                    //     if(rt[i].y != 6.) { // not pillar\n                    //         V ps = pb;\n                    //         // repetition\n                    //         v l = ss[i].xz;\n                    //         ps.xz += (l - 1.) / 2.;\n                    //         ps.xz = ps.xz - clamp(floor(ps.xz + .5), v(0.), l - 1.);\n                            \n                    //         // position\n                    //         ps.y -= ss[i].y / 2. + .02;\n    \n                    //         F stud = tube(ps, V(.24, .28, mix(EPS,.18,${m[1]}.)));\n                    //         block = min(stud, block);\n                    //     }\n                \n                    //     if(pb.z<.01 && (rt[i].y == 3. || rt[i].y == 4.)) { // beak\n                    //         block = smax(block,dot(pb,V(0,.78*(7.-2.*rt[i].y),-.624))-.39);\n                    //     }\n                \n                \n                \n                    //     if(rt[i].y == 7.) { // eye\n                    //         // F eye_ = cyl(pb, V(.2, .25, .2), cornerR);\n                    //         F eye_ = tube(pb+V(0,.25-cornerR*2.,0),V(.4-cornerR*2.,.45,0));\n                    //         block = eye_;\n                    //         if(eye_ < EPS) {\n                    //             eye = 1;\n                    //         }\n                    //     }\n                \n                    //     // block = L(pb)-2.;\n                    //     if(block < res) {\n                    //         res = block;\n                    //         colIds = cs[i];\n                    //     }\n                    //     if(res < EPS)\n                    //         break;\n                    // }\n                    // →res;\n                }\n                \n                V norm(V p) {\n                    v e = v(.01, 0.);\n                    →N(V(dist(p + e.xyy) - dist(p - e.xyy), dist(p + e.yxy) - dist(p - e.yxy), dist(p + e.yyx) - dist(p - e.yyx)));\n                }\n\n                float sdfVoxel(vec3 p){\n                    p = floor(p) + .5;\n                    // return fract(9e5*sin(9e5*dot(p,vec3(7,2,3))))-.5;\n                    return length(p) - 2.;\n                }\n\n                void main() {\n                    ${q}\n                    V o = V(0);\n                    v uv, uvI = (gl_FragCoord.xy * 2. - rs)/rs;\n        \n                    for(F A = 0.; A < 8.; A++){\n                        if(A >= aa) break;\n                        gl = 0.;\n                        F d = 0., e = 1e9, ep, j; // here highp\n        \n                        F fl = floor(A/2.);\n                        F fr = mod(A,2.);\n                        v pos = v(fr/2.,fl/4.)-.5;\n                        if(mod(fl, 2.)==0.) pos.x += .25; //https://bit.ly/30g2DXs\n        \n                        v uv = uvI;\n    \n                        uv += pos * 2. / rs;\n        \n                        V n, p, ro = V(uv * F(${g[6]}) +\n                            v(${g[7]},\n                            ${g[8]}), -camDist), \n                           rd = V(0, 0, .9 + .1 * fract(1e3 * sin(1e3 * fract(L(uv)))));\n                        bool outline = false;\n\n                        // RAYMARCH\n\n\n                        // TODO ro, rd\n\n                        // MY LEGO VERSION\n                        // for(F i = 0.; i < 1e2; i++) {\n                        //     j = i;\n                        //     p = d * rd + ro;\n                        //     p.z -= camDist;\n                        //     p.yz *= rot(${O});\n                        //     p.xz *= rot(${a}); // FIXME не каждый шаг реймарша вычислять этот угол, предварительно RD повернуть и всё\n\n                        //     d += e = dist(p);\n                        //     if(ep < e && e < .01) {\n                        //         outline = true;\n                        //         break;\n                        //     }\n                        //     ep = e;\n                        //     if(e < EPS || e > camDist*2.)\n                        //         break;\n                        // }\n\n                        // vec3 ro = vec3(0,0,-10);\n                        // vec3 rd = vec3(0,0,-10);\n                        ro.yz *= rot(${O});\n                        rd.yz *= rot(${O});\n                        ro.xz *= rot(${a});\n                        rd.xz *= rot(${a});\n                        float ii = 0.;\n                        for(float i = 0.; i < 200.; i++) {\n                            ii++;\n                            p = ro + rd * d;\n                            vec3 dp = (step(0., rd) - fract(p)) / rd;\n                            float dpmin;\n                \n                            dpmin = min(min(dp.x,dp.y),dp.z) + 1e-4;\n                \n                            bool breaker = false;\n                            if(sdfVoxel(p) < 0.) {\n                                float ddd = 0.;\n                                for(float backupI = 0.; backupI < 200.;backupI++) {\n                                    ii++;\n                                    p = ro + rd * (d + ddd);\n                                    ddd += e = dist(fract(p) - .5);\n                                    // if(e < .001 || ++i > 200.) { // FIXME restore this i++ condition\n                                    if(e < .001 || ii > 100.) { // налетели на сферу\n                                        n = norm(fract(p) - .5);\n                                        // if(id > 0.)\n                                        //     col *= color(id);\n                                            // col *= n+.5;\n                                        // if(s > 1.)\n                                            // col *= .6;\n                                        breaker = true;\n                                        break;\n                                    }\n                                    if(ddd > dpmin) { // улетели в соседнюю клетку\n                                        break;\n                                    }\n                                }\n                            }\n                            if(breaker == true || ii > 100.)\n                                break;\n                \n                            d += dpmin;\n                        }\n                \n\n                        V c;\n                        // if(!outline) {\n                        //     V col1, col2;\n                        //     for(int j = 0; j < 5; j++) {\n                        //         if(colIds[0] == j)\n                        //             col1 = pt[j];\n                        //         if(colIds[1] == j)\n                        //             col2 = pt[j];\n                        //     }\n                    \n                        //     V col = col1;\n                    \n                        //     // Texturing\n                        //     //\n                        //     // layers\n                        //     if(colIds.z == 1)\n                        //         if(sin(p.y * PI * 3.) > 0.)\n                        //             col = col2;\n                        //     if(colIds.z == 2)\n                        //         if(sin((p.x + fract(ps[0].x - ss[0].x / 2.)) * PI * 2. * 1.5) > 0.)\n                        //             col = col2;\n                                    \n                        //     // pride\n                        //     if(${m[3]} == 3)\n                        //         col = sin((L(p) / max(F(${s}), F(${m[8]})) * 2. - V(0, .3, .6)) * 6.28) * .5 + .5;\n                            \n                        //     if(eye == 1) {\n                        //         col = V(0);\n                        //         V pe = p + fract(${s}. / 2.);\n                        //         pe = fract(pe) - .5;\n                        //         col += step(.3, L(pe.xz));\n                        //         col += step(-.1, -L(pe.xz + .1));\n                        //     }\n                                    \n                        //     if(colIds.z == -1) {\n                        //         // // фончик\n                        //         c = texture2D(tex3d,gl_FragCoord.xy / rs).rgb;\n                                \n                        //         // c = V(${T})/255.;\n                        //         // if(L(c) > .4){\n                        //         //     c *= S(5., 0., L(uv + v(${m[6]}, -1)));\n                        //         // }\n                        //         // // c = V(1,0,1);\n                        //         // if(${m[3]} == 3){\n                        //         //     c = V(.2);\n                        //         // }\n                        //         // if(sin(L(pow(abs(uv), v(${m[5]}))) * 32.) > 0.)\n                        //         //     c *= .95;\n                        //     } else {\n                        //         c = V(1,0,1);\n                        //         // shading\n                        //         c = (min(1.5, 14. / j) * .2 + .8) * (dot(norm(p), N(V(0, 1, 1))) * .2 + .8) * col;\n                                \n                        //         // glare\n                        //         c += pow(abs(dot(norm(p), N(V(0., 3., 1.)))), 40.);\n                        //     }\n                        //     // gazya\n                        //     if(${m[3]} == 4)\n                        //         c = (V(7. / j));\n                            c = n * .5 + .5;\n                        // }\n                        o += c;\n                    }\n                    gl_FragColor = vec4(o/aa,1);\n                }`.replace(/@/g,"\n#define ").replace(/→/g,"return "),vert:"attribute vec2 g;void main(){gl_Position=vec4(g,0,1);}",attributes:{g:[[1,1],[1,-4],[-4,1]]},uniforms:{rs:W.prop("r"),pt:p.map(n=>n/255),aa:W.prop("a"),tex3d:Z},scissor:{enable:!0,box:{x:W.prop("x"),y:W.prop("y"),width:W.prop("t"),height:W.prop("t")}},depth:{enable:!1},count:3}),en=1+(G/F|0),on=0,rn=new Date,tn=1,an=1;M&&(an=Number(M));let ln=1;function*pn(){let[n,e,o,r]=[0,0,1,1];for(;;){for(;2*n*o<r;)yield[n,e],n+=o;for(;2*e*o<r;)yield[n,e],e+=o;o=-o,r++}}F=32;let sn=pn(),cn=W.frame(()=>{for(let n=0;n++<ln;){let[n,e]=sn.next().value;nn({r:G,x:G/2-F/2+F*n|0,y:G/2-F/2-F*e|0,t:F,a:an}),on++}r=+new Date;let n=r-rn;49==on&&1==an&&n<2e3?(on=0,sn=pn(),an=z(8,16/2**$.floor(n/500)),W.clear({color:[0,0,0,0]})):(on>49||an>1)&&(r-rn>160&&(ln=I(1,ln-8)),r-rn<30&&(ln+=2),rn=r),console.log(on),on>(2*(G/F/2|0)+3)**2&&cn.cancel()});'tx shvembldr piter stranger'