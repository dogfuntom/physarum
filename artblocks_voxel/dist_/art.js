let n,e,r,o,t,a;window.location.hash&&(tokenData.hash=window.location.hash.slice(1)),console.log(tokenData.hash);let l,c,i,s,p,f,d,m,x,b,v,g,u,_,y,k,z,F=Math,h=Array,V=F.min,D=F.max,$=F.floor,I=F.abs,w=F.cos,j=F.sin,C=devicePixelRatio,E=location.href.split("#")[1],N=n=>n[0].map((e,r)=>n.slice().reverse().map(n=>n[r])),R=0,B=3,P=4,L=5,S=6,q=7,M=30,A=.95532,O=[...Array(1e3)].map(()=>[...Array(10)].map(()=>[0,0,0])),X=()=>{n=new Uint32Array([4,1,e=o=2,3].map(n=>parseInt(tokenData.hash.substr(8*n,8),16))),r=()=>(o=n[3],n[3]=n[2],n[2]=n[1],n[1]=e=n[0],o^=o<<11,n[0]^=o^o>>>8^e>>>19,n[0]/2**32),t=(n,e)=>n[n.length*r()**(e||1)|0],a=n=>n.map(n=>[n,r()]).sort((n,e)=>n[1]-e[1]).map(n=>n[0]),u=[],u_tick=1e-6,x=[r()**4*2|0,r()**8*2|0,0,5*(1-r()**.3)|0,0,t([2,1],.5),(3*r()|0)-1,0,0,0,0],l=(x[0]-.5)*F.PI/2-F.PI;let b=[[8+2*r()|0,30,5,8,0],[4,3+4*r()|0,0,1,1],[8+2*r()|0,30,3,8,r()**4*8],[6+4*r()|0,10+20*r()|0,2,6,2*r()],[6+(0|r()),10+10*r()|0,0,4,r()**2*3]];x[4]=F.sqrt(1-(r()-1)**2)*b.length|0,[s,p,f,d,m]=b[x[4]],c=2+2*r()|0,g=[],x[2]=r()**.5*8|0,i="dddddd888888555555222222aaaaaaf26b21fbb04099ca3c208b3afcec529b5de5f15bb500bbf900f5d4fee440f1faeea8dadc457b9d1d3557e6394650514ff25f5c247ba070c1b3ffe066541388d90368f1e9da2e294effd4001f20414b3f72119da419647effc857540d6eee4266f3fcf01f271bffd23fe4572e29335ca8c686669bbcf3a712".substr(30*x[2],30).match(/(.{2})/g).map(n=>Number("0x"+n)),y=4*r()|0},K=()=>{let n=a([[[2,1,2],[[0,1],[0,1]],0,B],[[2,1,2],0,[[0,1],[0,1]],P],[[2,1,4],0,0,R],[[2,1,3],0,0,R],[[1,1,6],0,0,R],[[1,2,3],0,[[1,0,1]],L],[[1,1,3],0,0,R],[[2,1,2],0,0,R],[[1,1,1],0,0,R],[[1,2,1],0,0,R]].filter(n=>n[0][2]<s)).slice(0,c),e=a([[[1,4,1],[[0]],0,S],[[1,.5,1],[[0]],0,q]]);b=[...h(s)].map(()=>h(s).fill(0)),v=[...h(s)].map(()=>h(s).fill(0));for(let o=0;o<p;o++){let a,l,c,i=0,_=-9e9,y=0,k=t(n);o>=p-m&&(k=t(e,.7),f=6,d=6,y=1);for(let n=0;n<d;n++){c=JSON.parse(JSON.stringify(k)),c[4]=4*r()+1|0,c[5]=4*r()+1|0,2==x[3]&&(c[4]=c[5]=1),c[6]=4*r()|0,1==x[3]&&(c[6]=0),c[7]=1,c[8]=4*r()|0,c[3]==q&&(c[8]=0);let e=()=>h(9).fill(h(9).fill(1));c[2]=c[2]||e(),c[1]=c[1]||e(),c[9]=[...c[0]];for(let n=0;n<c[8];n++)c[9].reverse(),c[2]=N(c[2]),c[1]=N(c[1]),c[7]=!c[7];if(c[9][0]>s/2){d<M&&d++;continue}c[10]=s%2==0?[c[9][0]/2+(r()*(s/2+1-c[9][0])|0),0,-s/2+c[9][2]/2+(r()*(s+1-c[9][2])|0)]:[c[9][0]/2+(r()*((s-1)/2+1-c[9][0])|0)+.5,0,-s/2+c[9][2]/2+(r()*(s+1-c[9][2])|0)],c[9][0]%2==s%2&&r()<1/(s-c[9][0])&&(c[9][0]%2||c[7])&&(c[10][0]=0);let o=0,t=0,p=[...h(c[9][0])].map((n,e)=>c[10][0]+e-(c[9][0]-1)/2),m=[...h(c[9][2])].map((n,e)=>c[10][2]+e-(c[9][2]-1)/2);for(let n of p)for(let e of m)n>=0?t++:o++;let g=0,u=0,y=0,z=0;for(let n of m)for(let e of p){let r=z%c[9][0],o=$(z/c[9][0]);z++,u=D(u,b[e+s/2-.5][n+s/2-.5]),y=D(y,v[e+s/2-.5][n+s/2-.5]),1==c[2][r][o]&&(g=D(g,b[e+s/2-.5][n+s/2-.5]))}g<y||g>u?d<M&&d++:(a=[0,-F.hypot(c[10][0],c[10][2]),-g,-F.hypot(c[10][0],g-10,c[10][2]),-I(F.hypot(c[10][0],g-10,c[10][2])-s),-I(F.hypot(c[10][0],2*g,c[10][2])-s),2*g+c[10][2]][f],(a>_||0==n)&&(_=a,i=g,l=c))}if(l&&(l[10][1]=i+l[0][1]/2,l[10][1])){if(y&&l[10][1]-l[9][1]/2==0)continue;let n=h(l[9][0]).fill().map((n,e)=>l[10][0]+e-(l[9][0]-1)/2),e=h(l[9][2]).fill().map((n,e)=>l[10][2]+e-(l[9][2]-1)/2),r=0;for(let o of e)for(let e of n){let n=r%l[9][0],t=$(r/l[9][0]);r++,b[e+s/2-.5][o+s/2-.5]=i+l[0][1],0==l[1][n][t]&&(b[e+s/2-.5][o+s/2-.5]=-99),v[e+s/2-.5][o+s/2-.5]=i+l[0][1]}g.push(l);for(let n=0;n<l[9][0];n++)for(let e=0;e<l[9][1];e++)for(let r=0;r<l[9][2];r++){let o=l[10][0]-l[9][0]/2+n+5|0,t=l[10][1]-l[9][1]/2+e|0,a=l[10][2]-l[9][2]/2+r+5|0;O[a+10*t][o][0]=O[a+10*t+10][o][1]=255*(g.length+1)/64}for(let n=0;n++<8;){let e=[0,0,0].map((e,r)=>(n>>r&1)-.5);u.push([e[0]*(l[9][0]+2*l[10][0]),e[1]*l[9][1]+l[10][1],e[2]*l[9][2]+l[10][2]])}}}},U=()=>{_=[-99,99,99,-99];let n=(n,e,r)=>[n*w(r)-e*j(r),n*j(r)+e*w(r)];u.forEach(e=>{let[r,o,t]=e;[r,t]=n(r,t,-l),[o,t]=n(o,t,-A),_[2]=V(r,_[2]),_[3]=D(r,_[3]),_[1]=V(o,_[1]),_[0]=D(o,_[0])}),_[4]=_[3]-_[2],_[5]=_[0]-_[1],_[6]=D(_[4]/1.8,_[5]/1.8,1),_[7]=_[2]+_[4]/2,_[8]=_[1]+_[5]/2};X(),K(),U(),console.log(i),u_colors=g.map(n=>[n[4],n[5],n[6]]).flat();let G="";G+=g.map((n,e)=>`ps[${e}]=vec3(${n[10][0]},${n[10][1]},${n[10][2]});`).join(""),G+=g.map((n,e)=>`ss[${e}]=vec3(${n[0][0]},${n[0][1]},${n[0][2]});`).join(""),G+=g.map((n,e)=>`rt[${e}]=vec2(${n[8]},${n[3]});`).join(""),G+=g.map((n,e)=>`cs[${e}]=ivec3(${n[4]},${n[5]},${n[6]});`).join("");let W=Array(64).fill([[0,0,0]]),T=Array(64).fill([[0,0,0]]),J=Array(64).fill([[0,0,0]]),H=Array(64).fill([[0,0,0]]);g.forEach((n,e)=>{W[e]=[n[10]],T[e]=[n[0]],J[e]=[[n[8],n[3],0]],H[e]=[[n[4],n[5],n[6]]]});let Q=F.min(innerWidth,innerHeight)*C,Y=document.createElement("canvas");Y.style.width=Q/C+"px",Y.style.height=Q/C+"px",Q=V(Q,2048);let Z=Y.getContext("webgl",{preserveDrawingBuffer:!0});document.body.appendChild(Y);let nn=i.slice(3*y,3+3*y);Y.style.background=3==x[3]?"#333":`rgb(${nn})`,Y.width=Q,Y.height=Q;let en=createREGL({gl:Z,extensions:["webgl_draw_buffers","oes_texture_float"]}),rn=en.texture(O),on=en.texture({data:W,type:"float"}),tn=en.texture({data:T,type:"float"}),an=en.texture({data:J,type:"float"}),ln=en.texture({data:H,type:"float"}),cn=[1,1].map(()=>en.framebuffer({color:[en.texture({type:"float",width:Q,height:Q}),en.texture({type:"float",width:Q,height:Q})],depth:!1})),sn={frag:`#extension GL_EXT_draw_buffers : require\n                precision highp float;\n                #define BLOCKS_NUMBER_MAX 60\n                #define PI 3.1415\n                #define S smoothstep\n                #define V vec3\n                #define F float\n                #define N normalize\n                #define L length\n                #define v vec2\n                mat2 rot(F a) {→mat2(cos(a),-sin(a),sin(a),cos(a));} // FIXME make define\n                #define rnd(x) fract(54321.987 * sin(987.12345 * x + .1))\n                // #define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n                #define EPS .0001\n                F sabs(F p) {→sqrt(abs(p)*abs(p)+5e-5);}\n                F smax(F a, F b) {→(a+b+sabs(a-b))*.5;}\n                \n                V ps[BLOCKS_NUMBER_MAX];\n                V ss[BLOCKS_NUMBER_MAX];\n                v rt[BLOCKS_NUMBER_MAX];\n                ivec3 cs[BLOCKS_NUMBER_MAX];\n\n                uniform sampler2D sampler_ps;\n                uniform sampler2D sampler_ss;\n                uniform sampler2D sampler_rt;\n                uniform sampler2D sampler_cs;\n            \n\n                uniform V pt[5];\n                uniform F tk;\n                uniform F rs;\n\n                uniform sampler2D tex3d;\n                uniform sampler2D texCol;\n                uniform sampler2D texNorm;\n        \n                ivec3 colIds = ivec3(0);\n                F gl;\n                F camDist = 30.;\n                ivec2 blockId;\n                F cornerR = .01, gap = .015, block;\n                F outlineWidth = .015;//((cornerR+gap)*sqrt(2.) - cornerR);\n                \n                // int eye = 0;\n                // V eye = V(0.);\n                // eye = 0;\n                int id;\n    \n                F tube(V p, V s){\n                    v po = v(L(p.xz), p.y - clamp(p.y, EPS, s.x));\n                    po.x -= clamp(po.x, s.z, s.y);\n                    →L(po)-EPS;\n                }\n                \n\n                F dist(V p, F id) {\n\n                    V val_from_sampler_ps = (texture2D(sampler_ps, vec2(.5,(id)/64.)).rgb);\n                    V val_from_sampler_rt = (texture2D(sampler_rt, vec2(.5,(id)/64.)).rgb);\n                    V val_from_sampler_ss = (texture2D(sampler_ss, vec2(.5,(id)/64.)).rgb);\n                    ivec3 val_from_sampler_cs = ivec3(texture2D(sampler_cs, vec2(.5,(id)/64.)).rgb);\n                    // ivec3 val_from_sampler_cs = ivec3(1,2,1);\n\n                    p.x = abs(p.x);\n                    V pb = p;\n                    pb -= val_from_sampler_ps;\n                    pb.xz *= rot(val_from_sampler_rt.x * PI / 2.);\n                    \n                    // box\n                    // F cornerR = .01, gap = .008, block;\n                    \n                    V s = val_from_sampler_ss - 2. * (cornerR + gap);\n                    block = L(pb - clamp(pb, -s/2., s/2.)) - cornerR * 1.4;\n                    // if(blockId==0) {colIds = ivec3(3, 2, 1); return length(fract(p)-.5)-.45;}\n                        \n                    if(val_from_sampler_rt.y == 5.) { // arc\n                        F cyl = L(pb.zy) - .5;\n                        F box = max(abs(pb.z) - .5, abs(pb.y + val_from_sampler_ss.y / 2.) - 1.);\n                        F hole = min(cyl, box);\n                        block = max(block, -hole);\n                    }\n\n                    if(val_from_sampler_rt.y == 6.) { // pillar\n                        F narrow = tube(pb+V(0,1.6-cornerR*3.,0),V(3.55,.15,0));\n                        F base = tube(pb+V(0,2.-cornerR*2.,0),V(.4-cornerR*2.,.45,0));\n                        block = min(narrow, base);\n                        // // F narrow = tube(pb+V(0,1.6-cornerR-gap,0),V(3.55,.15,0));\n                        // F narrow = tube(pb+V(0,4./2.-.4-cornerR*2.-gap,0),V(3.55,.15-cornerR,0));\n                        // F base = tube(pb+V(0,2.-cornerR*2.,0),V(.4-cornerR*2.-gap,.45,0));\n                        // block = min(narrow, base)-cornerR;\n                    }\n\n                    // studs\n                    if(val_from_sampler_rt.y != 6.) { // not pillar\n                        V ps = pb;\n                        // repetition\n                        v l = val_from_sampler_ss.xz;\n                        ps.xz += (l - 1.) / 2.;\n                        ps.xz = ps.xz - clamp(floor(ps.xz + .5), v(0.), l - 1.);\n                        \n                        // position\n                        ps.y -= val_from_sampler_ss.y / 2. + .02;\n\n                        F stud = tube(ps, V(.24, .28, mix(EPS,.18,${x[1]}.)));\n                        block = min(stud, block);\n                    }\n            \n                    if(pb.z<.01 && (val_from_sampler_rt.y == 3. || val_from_sampler_rt.y == 4.)) { // beak\n                        block = smax(block,dot(pb,V(0,.78*(7.-2.*val_from_sampler_rt.y),-.624))-.39);\n                    }\n            \n            \n            \n                    if(val_from_sampler_rt.y == 7.) { // eye\n                        F eye_ = tube(pb+V(0,.25-cornerR*2.,0),V(.4-cornerR*2.,.45,0));\n                        block = eye_;\n                        if(eye_ < EPS) {\n                            colIds.z = 9; // eye\n                            // discard;\n                            // return block;\n                        }\n                    }\n            \n                    // block = L(pb)-2.;\n                    if(block < EPS) {\n                        // colIds = ivec3(1,2,1);\n                        if(colIds.z == 9)// FIXME как-то эти ифы упростить, они нужны только чтобы глаза работали. Может поднять над предыдущим абзацем?\n                            colIds = ivec3(val_from_sampler_cs.xy, 9);\n                        else\n                            colIds = val_from_sampler_cs;\n                    }\n                    →block;\n                }\n                \n                V norm(V p, F id) {\n                    // p+=.5;\n                    // →normalize(fract(p));\n                    v e = v(.01, 0.);\n                    →N(V(dist(p + e.xyy, id) - dist(p - e.xyy, id), dist(p + e.yxy, id) - dist(p - e.yxy, id), dist(p + e.yyx, id) - dist(p - e.yyx, id)));\n                }\n\n                void sdfVoxel(vec3 p){\n                    // blockId *= 0;\n                    // p.xz += fract(float(${s/2}));  // ODD\n                    // p.x = abs(p.x);\n                    // p.zx -= fract(float(${s/2})); // ODD\n                    // p.x += 5.;\n                    // p.z += 5.;\n                    // p = floor(p+vec3(0,0,0));\n                    // if(p.y < 0.) return v(0);\n                    // vec3 boundingBox = vec3(10,1000 / 10,10);\n                    // if(fract(p/boundingBox) != p/boundingBox) return v(0);\n                    // blockId = ivec2(max(0., 3.-length(p)));\n                    // return vec2(blockId);\n\n\n                    blockId *= 0;\n                    p.xz += fract(float(${s/2}));  // ODD\n                    // p.xz = p.zx;\n                    p.x = abs(p.x);\n                    p.zx -= fract(float(${s/2})); // ODD\n                    // p.x += ${s}.-1.;\n                    // p.z += ${s}.;\n                    p.x += 5.;\n                    p.z += 5.;\n                    p = floor(p+vec3(0,0,0));\n                    if(p.y < 0.) return; // ←←←←←←←←←←←←←←←←←←←←←←←←\n                    // p.x -= .5;\n                    // p.z -= .5;\n                    vec3 boundingBox = vec3(10,1000 / 10,10);\n                    if(fract(p/boundingBox) != p/boundingBox) return;  // ←←←←←←←←←←←←←←←←←←←←←←←←\n                    vec2 vox, texSize = vec2(boundingBox.x, boundingBox.y*boundingBox.z);\n                    vox.x = p.x;\n                    vox.y = p.z + p.y * 10.;\n                    vec2 voxN = (vox+.5) / texSize;\n                    blockId = ivec2(texture2D(tex3d, voxN).rg * 64.);\n                    // if(blockId == 2) discard;\n                    return;  // ←←←←←←←←←←←←←←←←←←←←←←←←\n                }\n\n                // vec3 rgb2hsb( in vec3 c ){\n                //     vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n                //     vec4 p = mix(vec4(c.bg, K.wz),\n                //                  vec4(c.gb, K.xy),\n                //                  step(c.b, c.g));\n                //     vec4 q = mix(vec4(p.xyw, c.r),\n                //                  vec4(c.r, p.yzx),\n                //                  step(p.x, c.r));\n                //     float d = q.x - min(q.w, q.y);\n                //     float e = 1.0e-10;\n                //     return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                //                 d / (q.x + e),\n                //                 q.x);\n                // }\n                \n                // //  Function from Iñigo Quiles\n                // //  https://www.shadertoy.com/view/MsS3Wc\n                // vec3 hsb2rgb( in vec3 c ){\n                //     vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                //                              6.0)-3.0)-1.0,\n                //                      0.0,\n                //                      1.0 );\n                //     rgb = rgb*rgb*(3.0-2.0*rgb);\n                //     return c.z * mix(vec3(1.0), rgb, c.y);\n                // }\n\n                void main() {\n                    // gl_FragData[0] = vec4(1);\n                    \n                    // // DEBUG\n                    // vec2 uv = (gl_FragCoord.xy * 2. - rs) / rs;\n                    // V ro = V(uv * F(${_[6]}) +\n                    //     v(${_[7]},\n                    //     ${_[8]}), -camDist),\n                    //    rd = V(0, 0, 1);\n                    //    ro.yz *= rot(${A});\n                    //    rd.yz *= rot(${A});\n                    //    ro.xz *= rot(${l});\n                    //    rd.xz *= rot(${l});\n                    // float d,e=1.,j;\n                    // vec3 p;\n                    // for(float i=0.;i<99.;i++){\n                    //     j=i;\n                    //     p=ro+rd*d;\n                    //     p.z-=1.;\n                    //     p.xz = fract(p.xz)-.5;\n                    //     d+=e=dist(p);\n                    //     if(e<1e-3)break;\n                    // }\n                    // gl_FragData[0] = vec4(step(-40.,-d));\n                    // vec3 n = norm(p);\n                    // // n.xz *= -rot(${l});\n                    // // n.xz *= -rot(${l});\n                    // // n.xz *= -rot(${l});\n                    // // n.yz *= rot(${A});\n                    // // n.xy *= rot(.95);\n                    // n.xz *= rot(PI/2. + PI/4.);\n                    // n.xy *= rot(atan(sqrt(2.)));\n                    // n = n.zyx;\n                    // n.x *= -1.;\n                    // n.z *= -1.;\n\n                    // gl_FragData[1] = vec4((n),d);\n                    // return;\n                    // // END OF DEBUG\n\n\n                    ${G}\n                    V o = V(0), n, nnn;\n                    v uv = (gl_FragCoord.xy * 2. - rs)/rs;\n                    F d;\n        \n                    gl = 0.;\n                    F e = 1e9, ep=9., j; // here highp\n                    d = 0.;\n    \n                    F fl = floor(tk/2.);\n                    F fr = mod(tk,2.);\n                    v pos = v(fr/2.,fl/4.)-.5;\n                    if(mod(fl, 2.)==0.) pos.x += .25; //https://bit.ly/30g2DXs\n    \n                    uv += pos * 2. / rs;\n    \n                    V p, ro = V(uv * F(${_[6]}) +\n                        v(${_[7]},\n                        ${_[8]}), -camDist),\n                        rd = V(0, 0, 1);\n                    bool outline = false;\n\n                    // vec3 ro = vec3(0,0,-10);\n                    // vec3 rd = vec3(0,0,-10);\n                    ro.yz *= rot(${A});\n                    rd.yz *= rot(${A});\n                    ro.xz *= rot(${l});\n                    rd.xz *= rot(${l});\n                    float jj = 0.;\n\n\n\n                    for(float i = 0.; i < 200.; i++) {\n                        jj++;\n                        p = ro + rd * d;\n                        p.xz -= fract(float(${s/2})); // ODD\n                        vec3 dp = (step(0., rd) - fract(p)) / rd;\n                        float dpmin;\n            \n                        dpmin = min(min(dp.x,dp.y),dp.z) + 1e-4;\n\n            \n                        bool breaker = false;\n                        sdfVoxel(p);\n                        // blockId = ivec2(2);\n                        if(length(v(blockId)) > 0. && p.y >= 0.) {\n                        // if(length(p)-5. < 0.) {\n                            float ddd = 0.;\n                            for(float backupI = 0.; backupI < 200.; backupI++) { // FIXME get rid of backupI\n                                jj++;\n                                p = ro + rd * (d + ddd);\n                                \n                                float e1 = dist(p,float(blockId.x - 1));\n                                float e2 = dist(p,float(blockId.y - 1));\n                                if(e1<e2){\n                                    e = e1;\n                                    id = blockId.x - 1;\n                                }\n                                else{\n                                    e = e2;\n                                    id = blockId.y - 1;\n                                }\n                                ddd += e;\n\n                                if(ep < e && e < outlineWidth) {\n                                    outline = true;\n                                    breaker = true;\n                                    dpmin = ddd;\n                                    break;\n                                }\n                                ep = e;\n                                if(e < EPS || jj > 200. || d > camDist*2.) { // налетели на сферу\n                                    // discard;\n                                    // if(id > 0.)\n                                    //     col *= color(id);\n                                        // col *= n+.5;\n                                    // if(s > 1.)\n                                        // col *= .6;\n                                    breaker = true;\n                                    dpmin = ddd;\n                                    break;\n                                }\n                                if(ddd > dpmin) { // улетели в соседнюю клетку\n                                    break;\n                                }\n                            }\n\n                            // breaker = true;\n                            // colIds = ivec3(1,1,1);\n                            // break;\n                        }\n                        else{\n                            colIds = ivec3(0, 0, -1);\n                        }\n                        d += dpmin;\n                        if(breaker == true || jj > 200.)\n                        break;\n                            \n                    }\n\n                    V c;\n                    if(!outline) {\n\n                        V col1, col2;\n                        for(int j = 0; j < 5; j++) {\n                            if(colIds[0] == j)\n                            col1 = pt[j]; //////////////////////\n                                // col1 = vec3(1,0,0); //////////////////////\n                            if(colIds[1] == j)\n                                // col2 = vec3(1,0,1); //////////////////////\n                            col2 = pt[j]; //////////////////////\n                        }\n                        \n                        V col = col1;\n                        \n                        // Texturing\n                        //\n                        // layers\n                        if(colIds.z == 1)\n                            if(sin(p.y * PI * 3.) > 0.)\n                                col = col2;\n                        if(colIds.z == 2)\n                            if(sin((p.x + fract(ps[0].x - ss[0].x / 2.)) * PI * 2. * 1.5) > 0.) //////////////////////\n                                col = col2;\n                        \n                        // pride\n                        if(${x[3]} == 3)\n                            col = sin((L(p) / max(F(${s}), F(${x[8]})) * 2. - V(0, .3, .6)) * 6.28) * .5 + .5;\n\n                        n = norm(p,float(id)); // надо тут вычислять, видимо, где-то выше я сбиваю colIds выполняя дист\n                        // иначе colIds.z равен 0 с чего-то. Но почему тогда dist(p); не помогает?\n                        if(colIds.z == 9) {\n                            col = V(0);\n                            V pe = p + fract(${s}. / 2.);\n                            pe = fract(pe) - .5;\n                            col += step(.3, L(pe.xz));\n                            col += step(-.1, -L(pe.xz + .1));\n                        }\n                    \n                        if(colIds.z == -1) {\n                            // фончик\n                            // c = texture2D(sampler_ps,gl_FragCoord.xy / rs).rgb; //tex3d\n                            \n                            c = V(${nn})/255.;\n                            if(L(c) > .4){\n                                c *= S(5., 0., L(uv + v(${x[6]}, -1)));\n                            }\n                            // c = V(1,0,1);\n                            if(${x[3]} == 3){\n                                c = V(.2);\n                            }\n                            if(sin(L(pow(abs(uv), v(${x[5]}))) * 32.) > 0.)\n                            c *= .95;\n                        } else {\n                            // c = V(1,0,1);\n                            // shading\n                            c = col;\n                            c *= min(1.5, 55. / jj) * .2 + .8;\n                            c *= dot(n, N(V(-.5,.5,0))) * .2 + 1.;\n\n                            // glare\n                            if(colIds.z!=9)\n                                c += pow(abs(dot(n, N(V(0, 1.5, .5)))), 40.);\n                        }\n                        // gazya\n                        // if(${x[3]} == 4)\n                        //     c = (V(20. / jj));\n                    }\n                    // n = norm(p);\n                    // c = n;\n                    // // texture debug\n                    // c.g = fract(gl_FragCoord.y / rs * 11.);\n                    // c.g *= pow(fract(gl_FragCoord.y / rs * 1000.),8.);// * fract(gl_FragCoord.x / rs * 10.);\n                    // c.g += step(0.001,texture2D(tex3d, gl_FragCoord.xy / rs).r) * 8.;\n                    // c *= 30./jj;\n\n                    // o += c;\n                    // nnn+=n;\n\n\n                    if(tk > 1.){\n                        V norm = (texture2D(texNorm, gl_FragCoord.xy/rs).rgb);\n                        F dist = texture2D(texNorm, gl_FragCoord.xy/rs).a;\n                        dist = min(dist,camDist*2.);\n                        vec3 f = norm;\n                        vec3 r = normalize(cross(vec3(1,2,3), f));\n                        vec3 u = cross(f, r);\n                        for(float i=0.; i<20.; i++){\n                            V kernel = V(0,0,0);\n                            kernel += (rnd(i+tk+dot(uv*99.,vec2(.319,.137)))*2.-1.) * r;\n                            kernel += (rnd(i+tk+dot(uv*99.,vec2(.319,.137))+.1)*2.-1.) * u;\n                            kernel += (rnd(i+tk+dot(uv*99.,vec2(.319,.137))+.2)) * f;\n                            kernel = N(kernel) * pow(rnd(i+dot(mod(gl_FragCoord.xy,10.1*PI),vec2(.319,.137))),2.);\n                            vec3 offset = V(dot(kernel,vec3(1,0,0)), dot(kernel,vec3(0,1,0)), dot(kernel,V(0,0,1)));\n                            if(dist - offset.z * 1.1 > texture2D(texNorm, gl_FragCoord.xy/rs + .15 * offset.xy).a){\n                                // gl_FragData[0] *= .99;\n                                c*=.97;\n                            }\n                        }\n                    }\n\n\n                    gl_FragData[0] = mix(texture2D(texCol, gl_FragCoord.xy/rs), c.rgbb, 1. / tk);\n                    // n.xz *= rot(PI/2. + PI/4.);\n                    n.xz *= -sign(${x[0]-.5})*rot(${l});\n                    n.xy *= rot(atan(sqrt(2.)));\n                    n = n.zyx;\n                    n.xz *= -1.;\n                    gl_FragData[1] = mix(texture2D(texNorm, gl_FragCoord.xy/rs), vec4(n.rgb,d), 1. / tk);\n\n\n                    // gl_FragData[0] = vec4(tk/8.);\n                    // gl_FragData[0].r = sin(length(gl_FragCoord.xy)/tk);\n\n                }\n                \n                \n                \n                \n                \n                \n                `.replace(/@/g,"\n#define ").replace(/→/g,"return "),vert:"attribute vec2 g;void main(){gl_Position=vec4(g,0,1);}",attributes:{g:[[1,1],[1,-4],[-4,1]]},uniforms:{rs:en.prop("r"),pt:i.map(n=>n/255),tex3d:rn,tk:({tick:n})=>n,texCol:({tick:n})=>cn[n%2].color[0],texNorm:({tick:n})=>cn[n%2].color[1],sampler_ps:on,sampler_ss:tn,sampler_rt:an,sampler_cs:ln},depth:{enable:!1},framebuffer:({tick:n})=>cn[(n+1)%2],count:3},pn=en({frag:"#extension GL_EXT_draw_buffers : require\n                precision highp float;\n                uniform float rs;\n                uniform sampler2D texCol;\n                // uniform sampler2D texNorm;        \n                void main() {\n                    gl_FragData[0] = texture2D(texCol,gl_FragCoord.xy/rs);\n                    gl_FragData[0].a = 1.;\n                }",vert:"attribute vec2 g;void main(){gl_Position=vec4(g,0,1);}",attributes:{g:[[1,1],[1,-4],[-4,1]]},uniforms:{rs:en.prop("r"),texCol:({tick:n})=>cn[(n+1)%2].color[0]},depth:{enable:!1},count:3}),fn=en(sn),dn=1+(Q/z|0),mn=new Date,xn=1,bn=1;E&&(bn=Number(E));let vn=1;z=256;let gn=en.frame(({tick:n})=>{fn({r:Q}),pn({r:Q}),n>8&&(document.title="👾",gn.cancel())});'tx shvembldr piter stranger'