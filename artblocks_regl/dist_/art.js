let e,n,o,t,s,a;tokenData.hash="0x36cd6a65a9949303468cbdf2b9ecae21cfac999127dbc90b1ca85381baadeb91",console.log(tokenData.hash);let l=Math,rotArray=e=>e[0].map(((n,o)=>e.slice().reverse().map((e=>e[o]))));const r=0,i=3,p=4,c=5,f=6,m=7,y=30;let b,d,u,h,g,v,x,k,z,_,w,S,B,$,C,V,A,N,E,M,R,D,F,P,T,I=.95532,L=40,X=10,init=()=>{e=Uint32Array.from([0,1,n=t=2,3].map((e=>parseInt(tokenData.hash.substr(8*e+2,8),16)))),o=()=>(t=e[3],e[3]=e[2],e[2]=e[1],e[1]=n=e[0],t^=t<<11,e[0]^=t^t>>>8^n>>>19,e[0]/2**32),s=(e,n)=>e[e.length*o()**(n||1)|0],a=e=>e.map((e=>[e,o()])).sort(((e,n)=>e[1]-n[1])).map((e=>e[0])),V=[],A=1e-6,S={Symmetry:o()**4*2|0,Studs:o()**8*2|0,Palette:0,ColorScheme:5*(1-o()**.3)|0,Layout:0,Height:0,Eyes:0,Aerials:0,BlocksNumber:0,BackgroundType:s([2,1],.5),BackgroundLight:(3*o()|0)-1},b=3.1415*(S.Symmetry-.5)/2-3.1415;let l=[{gs:8+2*o()|0,blocksNumber:30,fitnessFunctionNumber:5,maxTry:8,extra:0},{gs:8+2*o()|0,blocksNumber:30,fitnessFunctionNumber:3,maxTry:8,extra:o()**4*8},{gs:4,blocksNumber:3+4*o()|0,fitnessFunctionNumber:0,maxTry:1,extra:1},{gs:6+4*o()|0,blocksNumber:10+20*o()|0,fitnessFunctionNumber:2,maxTry:6,extra:2*o()},{gs:6+(0|o()),blocksNumber:10+10*o()|0,fitnessFunctionNumber:0,maxTry:4,extra:o()**2*3}];S.Layout=o()**.3*l.length|0,({gs:x,blocksNumber:k,fitnessFunctionNumber:z,maxTry:_,extra:w}=l[S.Layout]),d=2+2*o()|0,C=[],S.Palette=o()**.5*8|0,v="dddddd888888555555222222aaaaaaf26b21fbb04099ca3c208b3afcec529b5de5f15bb500bbf900f5d4fee440f1faeea8dadc457b9d1d3557e6394650514ff25f5c247ba070c1b3ffe066541388d90368f1e9da2e294effd4001f20414b3f72119da419647effc857540d6eee4266f3fcf01f271bffd23fe4572e29335ca8c686669bbcf3a712".slice(30*S.Palette,30*(S.Palette+1)),console.log("u_palette",v);let r=3*o()+1|0;v=v.substring(6*r)+v.substring(0,6*r),console.log("u_palette",v),v=v.match(/(.{2})/g).map((e=>Number("0x"+e)/255))};function placeBlocks(){let e=a([{size:[2,1,2],maskTop:[[0,1],[0,1]],type:i},{size:[2,1,2],maskBottom:[[0,1],[0,1]],type:p},{size:[2,1,4],type:r},{size:[2,1,3],type:r},{size:[1,1,6],type:r},{size:[1,2,3],maskBottom:[[1,0,1]],type:c},{size:[1,1,3],type:r},{size:[2,1,2],type:r},{size:[1,1,1],type:r},{size:[1,2,1],type:r}].filter((e=>e.size[2]<x))).slice(0,d),n=a([{size:[1,4,1],maskTop:[[0]],type:6},{size:[1,.5,1],maskTop:[[0]],type:7}]);B=[...Array(x)].map((()=>Array(x).fill(0))),$=[...Array(x)].map((()=>Array(x).fill(0)));for(let t=0;t<k;t++){let a,r,i,p=0,c=-9e9,f=0,m=s(e);t>=k-w&&4!=S.ColorScheme&&(m=s(n,.7),z=6,_=6,f=1);for(let e=0;e<_;e++){i=JSON.parse(JSON.stringify(m)),i.color=4*o()+1|0,i.color2=4*o()+1|0,2==S.ColorScheme&&(i.color=i.color2=1),i.texture=4*o()|0,1==S.ColorScheme&&(i.texture=0),i.symX=1,i.rot=4*o()|0,7==i.type&&(i.rot=0);let makeMask=()=>Array(9).fill(Array(9).fill(1));i.maskBottom=i.maskBottom||makeMask(),i.maskTop=i.maskTop||makeMask(),i.span=[...i.size];for(let e=0;e<i.rot;e++)i.span.reverse(),i.maskBottom=rotArray(i.maskBottom),i.maskTop=rotArray(i.maskTop),i.symX=!i.symX;if(i.span[0]>x/2){_<30&&_++;continue}i.pos=x%2==0?[i.span[0]/2+(o()*(x/2+1-i.span[0])|0),0,-x/2+i.span[2]/2+(o()*(x+1-i.span[2])|0)]:[i.span[0]/2+(o()*((x-1)/2+1-i.span[0])|0)+.5,0,-x/2+i.span[2]/2+(o()*(x+1-i.span[2])|0)],i.span[0]%2==x%2&&o()<1/(x-i.span[0])&&(i.span[0]%2||i.symX)&&(i.pos[0]=0);let n=0,t=0,s=[...Array(i.span[0])].map(((e,n)=>i.pos[0]+n-(i.span[0]-1)/2)),f=[...Array(i.span[2])].map(((e,n)=>i.pos[2]+n-(i.span[2]-1)/2));for(let e of s)for(let o of f)e>=0?t++:n++;let y=0,b=0,d=0,u=0;for(let e of f)for(let n of s){let o=u%i.span[0],t=floor(u/i.span[0]);u++,b=max(b,B[n+x/2-.5][e+x/2-.5]),d=max(d,$[n+x/2-.5][e+x/2-.5]),1==i.maskBottom[o][t]&&(y=max(y,B[n+x/2-.5][e+x/2-.5]))}y<d||y>b?_<30&&_++:(a=[0,-l.hypot(i.pos[0],i.pos[2]),-y,-l.hypot(i.pos[0],y-10,i.pos[2]),-abs(l.hypot(i.pos[0],y-10,i.pos[2])-x),-abs(l.hypot(i.pos[0],2*y,i.pos[2])-x),2*y+i.pos[2]][z],(a>c||0==e)&&(c=a,p=y,r=i))}if(r&&(r.pos[1]=p+r.size[1]/2,r.pos[1])){if(f&&r.pos[1]-r.span[1]/2==0)continue;let e=Array(r.span[0]).fill().map(((e,n)=>r.pos[0]+n-(r.span[0]-1)/2)),n=Array(r.span[2]).fill().map(((e,n)=>r.pos[2]+n-(r.span[2]-1)/2)),o=0;for(let t of n)for(let n of e){let e=o%r.span[0],s=floor(o/r.span[0]);o++,B[n+x/2-.5][t+x/2-.5]=p+r.size[1],0==r.maskTop[e][s]&&(B[n+x/2-.5][t+x/2-.5]=-99),$[n+x/2-.5][t+x/2-.5]=p+r.size[1]}C.push(r);for(let e=0;e++<8;){let n=[0,0,0].map(((n,o)=>(e>>o&1)-.5));V.push([n[0]*(r.span[0]+2*r.pos[0]),n[1]*r.span[1]+r.pos[1],n[2]*r.span[2]+r.pos[2]])}S.BlocksNumber++,7==r.type&&S.Eyes++,6==r.type&&S.Aerials++,r.pos[0]>0&&(S.BlocksNumber++,7==r.type&&S.Eyes++,6==r.type&&S.Aerials++)}}}let j,O,findViewBox=()=>{N={top:-1e9,bottom:1e9,left:1e9,right:-1e9};let rot=(e,n,o)=>[e*cos(o)-n*sin(o),e*sin(o)+n*cos(o)];V.forEach((e=>{let[n,o,t]=e;[n,t]=rot(n,t,-b),[o,t]=rot(o,t,-I),N.left=min(n,N.left),N.right=max(n,N.right),N.bottom=min(o,N.bottom),N.top=max(o,N.top)})),N.width=N.right-N.left,N.height=N.top-N.bottom,N.scale=max(N.width/1.8,N.height/1.8,1),N.offset={x:N.left+N.width/2,y:N.bottom+N.height/2}};function setup(){O=createDiv("").class("debug").size(800,100);try{init()}catch(e){document.querySelector(".debug").innerHTML=e}placeBlocks(),findViewBox(),console.log(v),u_colors=C.map((e=>[e.color,e.color2,e.texture])).flat();let e="";e+=C.map(((e,n)=>`positions[${n}]=vec3(${e.pos[0]},${e.pos[1]},${e.pos[2]});`)).join(""),e+=C.map(((e,n)=>`sizes[${n}]=vec3(${e.size[0]},${e.size[1]},${e.size[2]});`)).join(""),e+=C.map(((e,n)=>`colors[${n}]=ivec3(${e.color},${e.color2},${e.texture});`)).join(""),e+=C.map(((e,n)=>`roty[${n}]=vec2(${e.rot},${e.type});`)).join("");let n=Math.min(window.innerWidth,window.innerHeight)*window.devicePixelRatio,o=document.createElement("canvas");o.style.width=n/window.devicePixelRatio+"px",o.style.height=n/window.devicePixelRatio+"px",n=min(n,2048);let s=Math.floor(64e3/n),a=document.createElement("canvas");var l=o.getContext("2d");document.body.appendChild(a),document.body.appendChild(o),a.style.width=a.style.height=8,o.style.background=`rgb(${v.slice(0,3).map((e=>255*e))})`,4!=S.ColorScheme&&3!=S.ColorScheme||(o.style.background="#333"),a.width=s,a.height=n,o.width=n,o.height=n;var r=createREGL(a);console.log("regl.limits.maxViewportDims",r.limits.maxViewportDims),console.log("regl.limits.maxRenderbufferSize",r.limits.maxRenderbufferSize);const i=r({frag:`precision highp float;\n            #define BLOCKS_NUMBER_MAX 60\n            #define PI 3.1415\n            #define S smoothstep\n            #define V vec3\n            #define v vec2\n            float rnd(float x) {return fract(54321.987 * sin(987.12345 * mod(x,12.34567)));}\n            mat2 rot(float a) {return mat2(cos(a),-sin(a),sin(a),cos(a));}\n            #define STEPS 4e2\n            #define EPS .001\n            float sabs(float p) {return sqrt(abs(p)*abs(p)+5e-5);}\n            float smax(float a, float b) {return (a+b+sabs(a-b))*.5;}\n            \n            // vec3 positions[BLOCKS_NUMBER_MAX];\n            vec3 positions[BLOCKS_NUMBER_MAX];\n            // vec3 sizes[BLOCKS_NUMBER_MAX];\n            vec3 sizes[BLOCKS_NUMBER_MAX];\n            // vec2 roty[BLOCKS_NUMBER_MAX];\n            vec2 roty[BLOCKS_NUMBER_MAX];\n            // ivec3 colors[BLOCKS_NUMBER_MAX];\n            ivec3 colors[BLOCKS_NUMBER_MAX];\n            \n            uniform V palette[20];\n            uniform float aa;\n            uniform vec2 res;\n            uniform vec4 vb;\n    \n            ivec3 colIds;\n            float gl;\n            float camDist = 1e2;\n            // v u_res = v(${width}, ${height})*${pixelDensity()+1e-6};\n            \n\n\n\n\n\n            float cyl(V p, V s, float cornerR) {\n                // s.x — height\n                // s.y — thickness\n                // s.x — radius\n                p.y -= clamp(p.y, -s.x, s.x);\n                float len = length(p.xz) - s.z;\n                len -= clamp(len, -s.y, s.y);\n                float cyl = length(v(len, p.y)) - cornerR;\n                return cyl;\n            }\n\n\n\n\n            \n            int eye;\n\n            float tube(vec3 p, float h, float d, float innerHole){\n                // clamp height\n                p.y -= clamp(p.y, EPS, h);\n                // torus\n                vec2 po = vec2(length(p.xz), p.y);\n                // hole clamping\n                po.x -= clamp(po.x, innerHole, d);\n                return length(po)-EPS;\n            }\n            \n            float dist(V p) {\n                colIds = ivec3(0, 0, -1);\n                p.x = abs(p.x);\n                float res = p.y + 1.; // floor plane\n                for(int i = 0; i < BLOCKS_NUMBER_MAX; i++) {\n                    eye = 0;\n                    if(i >= ${C.length})\n                        break;\n                    V pb = p;\n                    pb -= positions[i];\n                    pb.xz *= rot(roty[i].x * PI / 2.);\n            \n                    // box\n                    float cornerR = .01;\n                    float gap = .008;\n                    float block;\n        \n                    // if(roty[i].y == 0. || roty[i].y == 3. || roty[i].y == 4. || roty[i].y == 5. || roty[i].y == 6.) {\n                    V s = sizes[i] - 2. * (cornerR + gap);\n                    block = length(pb - clamp(pb, -(s)/2., (s)/2.)) - cornerR * 1.4;\n                    // }\n            \n                    if(roty[i].y == 5.) { // arc\n                        float cyl = length(pb.zy) - .5;\n                        float box = max(abs(pb.z) - .5, abs(pb.y + sizes[i].y / 2.) - 1.);\n                        float hole = min(cyl, box);\n                        block = max(block, -hole);\n                    }\n\n\n\n                    // TODO reuse code for eye and the base of an\n                    if(roty[i].y == 6.) { // pillar\n                        // float cyl_ = length(pb.zx) - .15;\n\n                        float cyl_ = tube(pb+vec3(0,1.6-cornerR*2.,0),3.6-cornerR*2.,.15,0.);\n                        // float sph = cyl(\n                        //     pb + V(0, 0, 0) / 2., \n                        //     V(.2, .25, .2), \n                        //     0.);\n                        // s.x — height\n                        // s.y — thickness\n                        // s.x — radius\n                        float sph = tube(pb+vec3(0,2.-cornerR*2.,0),.4-cornerR*2.,.45,0.);\n                        block = min(cyl_, sph);\n                    }\n            \n\n\n\n\n                    // studs\n                    if(roty[i].y != 6.) { // not pillar\n                        V ps = pb;\n                        // repetition\n                        v l = sizes[i].xz;\n                        ps.xz += (l - 1.) / 2.;\n                        ps.xz = ps.xz - clamp(floor(ps.xz + .5), v(0.), l - 1.);\n                        \n                        // position\n                        ps.y -= sizes[i].y / 2. + .02;\n\n                        float stud = tube(ps, .24, .28, mix(EPS,.18,${S.Studs}.));\n                        block = min(stud, block);\n                    }\n            \n                    if(pb.z<0.15 && (roty[i].y == 3. || roty[i].y == 4.)) { // beak\n                        block = smax(block, (-pb.z*.8-(roty[i].y == 3. ? -1. : 1.)*pb.y-.5)/1.4142);\n                    }\n            \n            \n                    if(roty[i].y == 7.) { // eye\n                        // float eye_ = cyl(pb, V(.2, .25, .2), cornerR);\n                        float eye_ = tube(pb+vec3(0,.25-cornerR*2.,0),.4-cornerR*2.,.45,0.);\n                        block = eye_;\n                        if(eye_ < EPS) {\n                            eye = 1;\n                        }\n                    }\n            \n                    if(block < res) {\n                        res = block;\n                        colIds = colors[i];\n                    }\n                    if(res < EPS)\n                        break;\n                }\n                return res;\n            }\n            \n            V norm(V p) {\n                v e = v(.01, 0.);\n                return normalize(V(dist(p + e.xyy) - dist(p - e.xyy), dist(p + e.yxy) - dist(p - e.yxy), dist(p + e.yyx) - dist(p - e.yyx)));\n            }\n            void main() {\n                V o = V(0);\n                ${e}\n                vec2 uv, uvI = (gl_FragCoord.xy * 2. - res)/res;\n    \n                for(float A = 0.; A < 8.; A++){\n                    if(A >= aa) break;\n                    gl = 0.;\n                    float d = 0., e = 1e9, ep, j;\n    \n                    float fl = floor(A/2.);\n                    float fr = mod(A,2.);\n                    vec2 pos = vec2(fr/2.,fl/4.)-.5;\n                    if(mod(fl, 2.)==0.) pos.x += .25; //https://bit.ly/30g2DXs\n    \n                    // pos *= 0.;\n            \n                    // float tick = mod(f,8.);\n                    // float fl = floor(tick/2.);\n                    // float fr = mod(tick,2.);\n                    // vec2 pos = vec2(fr/2.,fract(fl/2.));\n                    // if(floor(fl/2.)==1.) pos += .25;\n            \n                    // float fl = floor(tick/4.);\n                    // float fr = mod(tick,4.);\n                    // vec2 pos = vec2(fr/4.,fl/8.);\n                    // if(mod(fl, 2.)==0.) pos.x += 1./8.; // https://bit.ly/3qFnhLs\n    \n                    vec2 uv = uvI;\n\n                    // pos*=0.; // FIXME\n\n                    uv += pos * 2. / res;\n                    // uv /= res/res_render;\n                    // uv -= 1.;\n                    // uv /= 2.;\n                    uv = uv * .5 + .5;\n                    uv *= vb.zw;\n                    uv += vb.xy;\n                    uv = uv * 2. - 1.;\n    \n                    V p, ro = V(uv * float(${N.scale}) + \n                    v(${N.offset.x},\n                    ${N.offset.y}), -camDist), \n                    rd = V(0, 0, .9 + .1 * rnd(length(uv)));\n                    bool outline = false;\n                    for(float i = 0.; i < STEPS; i++) {\n                        j = i;\n                        p = d * rd + ro;\n                        p.z -= camDist;\n                        p.yz *= rot(${I});\n                        p.xz *= rot(${b});\n                        d += e = dist(p);\n                        if(ep < e && e < .01) {\n                            // gl_FragColor = vec4(0);\n                            outline = true;\n                            break;\n                        }\n                        ep = e;\n                        if(e < EPS || e > camDist*2.)\n                            break;\n                    }\n                    V c;\n                    if(!outline) {\n                        V col1, col2;\n                        for(int j = 0; j < 20; j++) {\n                            if(colIds[0] == j)\n                                col1 = palette[j];\n                            if(colIds[1] == j)\n                                col2 = palette[j];\n                        }\n                \n                        V col = col1;\n                \n                        // Texturing\n                        //\n                        // layers\n                        if(colIds.z == 1)\n                            if(sin(p.y * PI * 3.) > 0.)\n                                col = col2;\n                        if(colIds.z == 2)\n                            if(sin((p.x + fract(positions[0].x - sizes[0].x / 2.)) * PI * 2. * 1.5) > 0.)\n                                col = col2;\n                                \n                        // pride\n                        if(${S.ColorScheme} == 3)\n                            col = sin((length(p) / max(float(${x}), float(${S.Height})) * 2. - V(0, .3, .6)) * 6.28) * .5 + .5;\n                        \n                        if(eye == 1) {\n                            col = V(0);\n                            V pe = p + fract(${x}. / 2.);\n                            pe = fract(pe) - .5;\n                            col += step(.3, length(pe.xz));\n                            col += step(-.1, -length(pe.xz + .1));\n                        }\n                                \n                        if(colIds.z == -1) {\n                            c = palette[0];\n                            if(length(c) > .4){\n                                c *= smoothstep(5., 0., length(uv + v(${S.BackgroundLight}, -1)));\n                            }\n                            // c = V(1,0,1);\n                            if(${S.ColorScheme} == 3){\n                                c = V(.2);\n                            }\n                            if(sin(length(pow(abs(uv), v(${S.BackgroundType}))) * 32.) > 0.)\n                                c *= .95;\n                        } else {\n                            c = V(1,0,1);\n                            // shading\n                            c = (min(1.5, 14. / j) * .2 + .8) * (dot(norm(p), normalize(V(0, 1, 1))) * .2 + .8) * col;\n                            \n                            // glare\n                            c += pow(abs(dot(norm(p), normalize(V(0., 3., 1.)))), 40.);\n                            // c.r = 1.;\n                        }\n                    }\n                    \n                    // gazya\n                    if(${S.ColorScheme} == 4)\n                        c = (V(7. / j));\n                \n                    // gl_FragColor = vec4(o*rnd(${A}), 1);\n                    // gl_FragColor=vec4(uv,0,1);\n                    // gl_FragColor = vec4(o, 1);\n                    // gl_FragColor = mix(texture2D(backbuffer, uv * v(1, -1) * .5 + .5), vec4(o, 1), 1. / (tick + 1.));\n                    // o += step(.5,fract(length(uv)*4.));\n                    o += c;\n                }\n                gl_FragColor = vec4(o/aa,1);\n                // gl_FragColor = vec4(vec3(mod(gl_FragCoord.x/2.+gl_FragCoord.y/2.,2.)),1);\n                // gl_FragColor = vec4(1,0,0,1);\n            }`,vert:"attribute vec2 position;void main(){gl_Position=vec4(position,0,1);}",attributes:{position:[[-1,-1],[-1,1],[1,-1],[-1,1],[1,-1],[1,1]]},uniforms:{res:r.prop("res"),palette:v,aa:r.prop("aa"),vb:r.prop("vb")},scissor:{enable:!0,box:{x:r.prop("x"),y:r.prop("y"),width:r.prop("w"),height:r.prop("h")}},count:6});t=+new Date;let p,c=1,f=8,m=0,y=Math.floor(n/64),d=-y,u=r.frame((function(){i({res:[d+c,n],vb:[d/n,0,(d+c)/n,1],x:0,y:0,h:n,w:c,aa:f}),0==m?(l.drawImage(a,0,0,.01,n,d-y/2,0,y,n),d+=y,d>n&&(d=0,m=1,f=1,f=8,console.log("(new Date() - t)",new Date-t),console.log("(new Date() - t) * size_ / 64 * 8 / 146",(new Date-t)*n/64*8/146*S.BlocksNumber/29),console.log(f),p=+new Date)):(window.document.title=(d/n).toFixed(3),l.drawImage(a,d,0),d+=c,new Date-t>160&&(c=Math.max(1,c-4)),new Date-t<80&&(c=Math.min(s,c+4)),t=+new Date,d>n&&(window.document.title="👾",console.log("FINISHED in ",new Date-p),u.cancel()))}))}'tx shvembldr piter stranger'