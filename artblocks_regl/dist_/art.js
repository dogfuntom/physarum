let e,n,o,t,s,a;console.log(tokenData.hash);let l=Math,r=l.min,i=l.max,p=l.floor,c=l.abs,f=l.cos,m=l.sin,y=location.href.split("#")[1],rotArray=e=>e[0].map(((n,o)=>e.slice().reverse().map((e=>e[o]))));const b=0,u=3,d=4,g=5,h=6,x=7,v=30;let k,z,S,V,$,w,B,_,A,N,P,C,E,R,T,j,D,I,M,L,X=.95532,init=()=>{e=new Uint32Array([0,1,n=t=2,3].map((e=>parseInt(tokenData.hash.substr(8*e+2,8),16)))),o=()=>(t=e[3],e[3]=e[2],e[2]=e[1],e[1]=n=e[0],t^=t<<11,e[0]^=t^t>>>8^n>>>19,e[0]/2**32),s=(e,n)=>e[e.length*o()**(n||1)|0],a=e=>e.map((e=>[e,o()])).sort(((e,n)=>e[1]-n[1])).map((e=>e[0])),j=[],u_tick=1e-6,C={Symmetry:o()**4*2|0,Studs:o()**8*2|0,Palette:0,ColorScheme:5*(1-o()**.3)|0,Layout:0,Height:0,Eyes:0,Aerials:0,BlocksNumber:0,BackgroundType:s([2,1],.5),BackgroundLight:(3*o()|0)-1},k=3.1415*(C.Symmetry-.5)/2-3.1415;let l=[{gs:8+2*o()|0,blocksNumber:30,fitnessFunctionNumber:5,maxTry:8,extra:0},{gs:8+2*o()|0,blocksNumber:30,fitnessFunctionNumber:3,maxTry:8,extra:o()**4*8},{gs:4,blocksNumber:3+4*o()|0,fitnessFunctionNumber:0,maxTry:1,extra:1},{gs:6+4*o()|0,blocksNumber:10+20*o()|0,fitnessFunctionNumber:2,maxTry:6,extra:2*o()},{gs:6+(0|o()),blocksNumber:10+10*o()|0,fitnessFunctionNumber:0,maxTry:4,extra:o()**2*3}];C.Layout=o()**.3*l.length|0,({gs:B,blocksNumber:_,fitnessFunctionNumber:A,maxTry:N,extra:P}=l[C.Layout]),z=2+2*o()|0,T=[],C.Palette=o()**.5*8|0,w="dddddd888888555555222222aaaaaaf26b21fbb04099ca3c208b3afcec529b5de5f15bb500bbf900f5d4fee440f1faeea8dadc457b9d1d3557e6394650514ff25f5c247ba070c1b3ffe066541388d90368f1e9da2e294effd4001f20414b3f72119da419647effc857540d6eee4266f3fcf01f271bffd23fe4572e29335ca8c686669bbcf3a712".slice(30*C.Palette,30*(C.Palette+1)),console.log("u_palette",w);let r=3*o()+1|0;w=w.substring(6*r)+w.substring(0,6*r),console.log("u_palette",w),w=w.match(/(.{2})/g).map((e=>Number("0x"+e)/255))};function placeBlocks(){let e=a([{size:[2,1,2],maskTop:[[0,1],[0,1]],type:u},{size:[2,1,2],maskBottom:[[0,1],[0,1]],type:d},{size:[2,1,4],type:b},{size:[2,1,3],type:b},{size:[1,1,6],type:b},{size:[1,2,3],maskBottom:[[1,0,1]],type:g},{size:[1,1,3],type:b},{size:[2,1,2],type:b},{size:[1,1,1],type:b},{size:[1,2,1],type:b}].filter((e=>e.size[2]<B))).slice(0,z),n=a([{size:[1,4,1],maskTop:[[0]],type:6},{size:[1,.5,1],maskTop:[[0]],type:7}]);E=[...Array(B)].map((()=>Array(B).fill(0))),R=[...Array(B)].map((()=>Array(B).fill(0)));for(let t=0;t<_;t++){let a,r,f,m=0,y=-9e9,b=0,u=s(e);t>=_-P&&4!=C.ColorScheme&&(u=s(n,.7),A=6,N=6,b=1);for(let e=0;e<N;e++){f=JSON.parse(JSON.stringify(u)),f.color=4*o()+1|0,f.color2=4*o()+1|0,2==C.ColorScheme&&(f.color=f.color2=1),f.texture=4*o()|0,1==C.ColorScheme&&(f.texture=0),f.symX=1,f.rot=4*o()|0,7==f.type&&(f.rot=0);let makeMask=()=>Array(9).fill(Array(9).fill(1));f.maskBottom=f.maskBottom||makeMask(),f.maskTop=f.maskTop||makeMask(),f.span=[...f.size];for(let e=0;e<f.rot;e++)f.span.reverse(),f.maskBottom=rotArray(f.maskBottom),f.maskTop=rotArray(f.maskTop),f.symX=!f.symX;if(f.span[0]>B/2){N<30&&N++;continue}f.pos=B%2==0?[f.span[0]/2+(o()*(B/2+1-f.span[0])|0),0,-B/2+f.span[2]/2+(o()*(B+1-f.span[2])|0)]:[f.span[0]/2+(o()*((B-1)/2+1-f.span[0])|0)+.5,0,-B/2+f.span[2]/2+(o()*(B+1-f.span[2])|0)],f.span[0]%2==B%2&&o()<1/(B-f.span[0])&&(f.span[0]%2||f.symX)&&(f.pos[0]=0);let n=0,t=0,s=[...Array(f.span[0])].map(((e,n)=>f.pos[0]+n-(f.span[0]-1)/2)),b=[...Array(f.span[2])].map(((e,n)=>f.pos[2]+n-(f.span[2]-1)/2));for(let e of s)for(let o of b)e>=0?t++:n++;let d=0,g=0,h=0,x=0;for(let e of b)for(let n of s){let o=x%f.span[0],t=p(x/f.span[0]);x++,g=i(g,E[n+B/2-.5][e+B/2-.5]),h=i(h,R[n+B/2-.5][e+B/2-.5]),1==f.maskBottom[o][t]&&(d=i(d,E[n+B/2-.5][e+B/2-.5]))}d<h||d>g?N<30&&N++:(a=[0,-l.hypot(f.pos[0],f.pos[2]),-d,-l.hypot(f.pos[0],d-10,f.pos[2]),-c(l.hypot(f.pos[0],d-10,f.pos[2])-B),-c(l.hypot(f.pos[0],2*d,f.pos[2])-B),2*d+f.pos[2]][A],(a>y||0==e)&&(y=a,m=d,r=f))}if(r&&(r.pos[1]=m+r.size[1]/2,r.pos[1])){if(b&&r.pos[1]-r.span[1]/2==0)continue;let e=Array(r.span[0]).fill().map(((e,n)=>r.pos[0]+n-(r.span[0]-1)/2)),n=Array(r.span[2]).fill().map(((e,n)=>r.pos[2]+n-(r.span[2]-1)/2)),o=0;for(let t of n)for(let n of e){let e=o%r.span[0],s=p(o/r.span[0]);o++,E[n+B/2-.5][t+B/2-.5]=m+r.size[1],0==r.maskTop[e][s]&&(E[n+B/2-.5][t+B/2-.5]=-99),R[n+B/2-.5][t+B/2-.5]=m+r.size[1]}T.push(r);for(let e=0;e++<8;){let n=[0,0,0].map(((n,o)=>(e>>o&1)-.5));j.push([n[0]*(r.span[0]+2*r.pos[0]),n[1]*r.span[1]+r.pos[1],n[2]*r.span[2]+r.pos[2]])}}}}let findViewBox=()=>{D=[-99,99,99,-99];let rot=(e,n,o)=>[e*f(o)-n*m(o),e*m(o)+n*f(o)];j.forEach((e=>{let[n,o,t]=e;[n,t]=rot(n,t,-k),[o,t]=rot(o,t,-X),D[2]=r(n,D[2]),D[3]=i(n,D[3]),D[1]=r(o,D[1]),D[0]=i(o,D[0])})),D[4]=D[3]-D[2],D[5]=D[0]-D[1],D[6]=i(D[4]/1.8,D[5]/1.8,1),D[7]=D[2]+D[4]/2,D[8]=D[1]+D[5]/2};init(),placeBlocks(),findViewBox(),console.log(w),u_colors=T.map((e=>[e.color,e.color2,e.texture])).flat();let F="";F+=T.map(((e,n)=>`positions[${n}]=vec3(${e.pos[0]},${e.pos[1]},${e.pos[2]});`)).join(""),F+=T.map(((e,n)=>`sizes[${n}]=vec3(${e.size[0]},${e.size[1]},${e.size[2]});`)).join(""),F+=T.map(((e,n)=>`colors[${n}]=ivec3(${e.color},${e.color2},${e.texture});`)).join(""),F+=T.map(((e,n)=>`roty[${n}]=vec2(${e.rot},${e.type});`)).join("");let O=Math.min(window.innerWidth,window.innerHeight)*window.devicePixelRatio,U=document.createElement("canvas");U.style.width=O/window.devicePixelRatio+"px",U.style.height=O/window.devicePixelRatio+"px",O=r(O,2048);const K=U.getContext("webgl",{preserveDrawingBuffer:!0});document.body.appendChild(U),U.style.background=`rgb(${w.slice(0,3).map((e=>255*e))})`,4!=C.ColorScheme&&3!=C.ColorScheme||(U.style.background="#333"),U.width=O,U.height=O;let H=16;var J=createREGL(K);const q=J({frag:`precision mediump float;\n                #define BLOCKS_NUMBER_MAX 60\n                #define PI 3.1415\n                #define S smoothstep\n                #define V vec3\n                #define v vec2\n                // float rnd(float x) {return ;}\n                mat2 rot(float a) {return mat2(cos(a),-sin(a),sin(a),cos(a));}\n                #define STEPS 4e2\n                #define EPS .001\n                float sabs(float p) {return sqrt(abs(p)*abs(p)+5e-5);}\n                float smax(float a, float b) {return (a+b+sabs(a-b))*.5;}\n                \n                vec3 positions[BLOCKS_NUMBER_MAX];\n                vec3 sizes[BLOCKS_NUMBER_MAX];\n                vec2 roty[BLOCKS_NUMBER_MAX];\n                ivec3 colors[BLOCKS_NUMBER_MAX];\n                \n                uniform V palette[5];\n                uniform float aa;\n                uniform float res;\n        \n                ivec3 colIds;\n                float gl;\n                float camDist = 1e2;\n                \n                int eye;\n    \n                float tube(vec3 p, V s){\n                    vec2 po = vec2(length(p.xz), p.y - clamp(p.y, EPS, s.x));\n                    po.x -= clamp(po.x, s.z, s.y);\n                    return length(po)-EPS;\n                }\n                \n                float dist(V p) {\n                    colIds = ivec3(0, 0, -1);\n                    p.x = abs(p.x);\n                    float res = p.y + 1.; // floor plane\n                    for(int i = 0; i < BLOCKS_NUMBER_MAX; i++) {\n                        eye = 0;\n                        if(i >= ${T.length})\n                            break;\n                        V pb = p;\n                        pb -= positions[i];\n                        pb.xz *= rot(roty[i].x * PI / 2.);\n                \n                        // box\n                        float cornerR = .01, gap = .008, block;\n            \n                        V s = sizes[i] - 2. * (cornerR + gap);\n                        block = length(pb - clamp(pb, -s/2., s/2.)) - cornerR * 1.4;\n                \n                        if(roty[i].y == 5.) { // arc\n                            float cyl = length(pb.zy) - .5;\n                            float box = max(abs(pb.z) - .5, abs(pb.y + sizes[i].y / 2.) - 1.);\n                            float hole = min(cyl, box);\n                            block = max(block, -hole);\n                        }\n    \n                        if(roty[i].y == 6.) { // pillar\n                            float narrow = tube(pb+vec3(0,1.6-cornerR*2.,0),V(3.55,.15,0));\n                            float base = tube(pb+vec3(0,2.-cornerR*2.,0),V(.4-cornerR*2.,.45,0));\n                            block = min(narrow, base);\n                        }\n\n                        // studs\n                        if(roty[i].y != 6.) { // not pillar\n                            V ps = pb;\n                            // repetition\n                            v l = sizes[i].xz;\n                            ps.xz += (l - 1.) / 2.;\n                            ps.xz = ps.xz - clamp(floor(ps.xz + .5), v(0.), l - 1.);\n                            \n                            // position\n                            ps.y -= sizes[i].y / 2. + .02;\n    \n                            float stud = tube(ps, V(.24, .28, mix(EPS,.18,${C.Studs}.)));\n                            block = min(stud, block);\n                        }\n                \n                        if(pb.z<.01 && (roty[i].y == 3. || roty[i].y == 4.)) { // beak\n                            block = smax(block,dot(pb,vec3(0,.78*(7.-2.*roty[i].y),-.624))-.39);\n                        }\n                \n                \n                \n                        if(roty[i].y == 7.) { // eye\n                            // float eye_ = cyl(pb, V(.2, .25, .2), cornerR);\n                            float eye_ = tube(pb+vec3(0,.25-cornerR*2.,0),V(.4-cornerR*2.,.45,0));\n                            block = eye_;\n                            if(eye_ < EPS) {\n                                eye = 1;\n                            }\n                        }\n                \n                        // block = length(pb)-2.;\n                        if(block < res) {\n                            res = block;\n                            colIds = colors[i];\n                        }\n                        if(res < EPS)\n                            break;\n                    }\n                    return res;\n                }\n                \n                V norm(V p) {\n                    v e = v(.01, 0.);\n                    return normalize(V(dist(p + e.xyy) - dist(p - e.xyy), dist(p + e.yxy) - dist(p - e.yxy), dist(p + e.yyx) - dist(p - e.yyx)));\n                }\n                void main() {\n                    ${F}\n                    V o = V(0);\n                    vec2 uv, uvI = (gl_FragCoord.xy * 2. - res)/res;\n        \n                    for(float A = 0.; A < 8.; A++){\n                        if(A >= aa) break;\n                        gl = 0.;\n                        highp float d = 0., e = 1e9, ep, j; // here highp\n        \n                        float fl = floor(A/2.);\n                        float fr = mod(A,2.);\n                        vec2 pos = vec2(fr/2.,fl/4.)-.5;\n                        if(mod(fl, 2.)==0.) pos.x += .25; //https://bit.ly/30g2DXs\n        \n                        vec2 uv = uvI;\n    \n                        uv += pos * 2. / res;\n        \n                        highp V p, ro = V(uv * float(${D[6]}) +\n                            v(${D[7]},\n                            ${D[8]}), -camDist), \n                           rd = V(0, 0, .9 + .1 * fract(1e3 * sin(1e3 * fract(length(uv)))));\n                        bool outline = false;\n                        for(float i = 0.; i < STEPS; i++) {\n                            j = i;\n                            p = d * rd + ro;\n                            p.z -= camDist;\n                            p.yz *= rot(${X});\n                            p.xz *= rot(${k});\n                            // d += e = length(p)-10.;\n                            d += e = dist(p);\n                            if(ep < e && e < .01) {\n                                outline = true;\n                                break;\n                            }\n                            ep = e;\n                            if(e < EPS || e > camDist*2.)\n                                break;\n                        }\n                        V c;\n                        if(!outline) {\n                            V col1, col2;\n                            for(int j = 0; j < 5; j++) {\n                                if(colIds[0] == j)\n                                    col1 = palette[j];\n                                if(colIds[1] == j)\n                                    col2 = palette[j];\n                            }\n                    \n                            V col = col1;\n                    \n                            // Texturing\n                            //\n                            // layers\n                            if(colIds.z == 1)\n                                if(sin(p.y * PI * 3.) > 0.)\n                                    col = col2;\n                            if(colIds.z == 2)\n                                if(sin((p.x + fract(positions[0].x - sizes[0].x / 2.)) * PI * 2. * 1.5) > 0.)\n                                    col = col2;\n                                    \n                            // pride\n                            if(${C.ColorScheme} == 3)\n                                col = sin((length(p) / max(float(${B}), float(${C.Height})) * 2. - V(0, .3, .6)) * 6.28) * .5 + .5;\n                            \n                            if(eye == 1) {\n                                col = V(0);\n                                V pe = p + fract(${B}. / 2.);\n                                pe = fract(pe) - .5;\n                                col += step(.3, length(pe.xz));\n                                col += step(-.1, -length(pe.xz + .1));\n                            }\n                                    \n                            if(colIds.z == -1) {\n                                c = palette[0];\n                                if(length(c) > .4){\n                                    c *= smoothstep(5., 0., length(uv + v(${C.BackgroundLight}, -1)));\n                                }\n                                // c = V(1,0,1);\n                                if(${C.ColorScheme} == 3){\n                                    c = V(.2);\n                                }\n                                if(sin(length(pow(abs(uv), v(${C.BackgroundType}))) * 32.) > 0.)\n                                    c *= .95;\n                            } else {\n                                c = V(1,0,1);\n                                // shading\n                                c = (min(1.5, 14. / j) * .2 + .8) * (dot(norm(p), normalize(V(0, 1, 1))) * .2 + .8) * col;\n                                \n                                // glare\n                                c += pow(abs(dot(norm(p), normalize(V(0., 3., 1.)))), 40.);\n                            }\n                            // gazya\n                            if(${C.ColorScheme} == 4)\n                                c = (V(7. / j));\n                        }\n                        o += c;\n                    }\n                    gl_FragColor = vec4(o/aa,1);\n                }`,vert:"attribute vec2 g;void main(){gl_Position=vec4(g,0,1);}",attributes:{g:[[1,1],[1,-4],[-4,1]]},uniforms:{res:J.prop("res"),palette:w,aa:J.prop("aa")},scissor:{enable:!0,box:{x:J.prop("x"),y:J.prop("y"),width:J.prop("ts_"),height:J.prop("ts_")}},count:3});let G=1+(O/M|0),W=0;function*spiral(){let[e,n,o,t]=[0,0,1,1];for(;;){for(;2*e*o<t;)yield[e,n],e+=o;for(;2*n*o<t;)yield[e,n],n+=o;o=-o,t++}}let Q=spiral();t=+new Date;let Y=1,Z=8,ee=1;M=32,L=2*(O/M/2|0)+3;let ne=0,oe=J.frame((function(){for(let e=0;e++<ee;){let[e,n]=Q.next().value;q({res:O,x:O/2-M/2+M*e|0,y:O/2-M/2-M*n|0,ts_:M,aa:Z}),W++}console.log("new Date() - t",new Date-t),new Date-t>160&&(ee=i(1,ee-2)),new Date-t<30&&(ee+=2),1==ee?ne++:ne=i(0,ne--),console.log("slowDevice",ne),ne>4&&(Z=1),y&&(Z=Number(y)),t=+new Date,W>L**2&&oe.cancel()}));'tx shvembldr piter stranger'